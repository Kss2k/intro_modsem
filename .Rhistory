if (is.null(listDf)) {
return(NULL)
} else if (length(listDf) <= 1)  {
print(listDf)
return(listDf)
} else if (is.data.frame(listDf))  {
return(listDf)
}
print(length(listDf))
# Basecase combine the first two columns of the df
# check if there are matching colnames (the first df has priority)
matchingColnames <- colnames(listDf[[2]]) %in% colnames(listDf[[1]])
combinedDf <- cbind.data.frame(listDf[[1]], listDf[[2]][!matchingColnames])
combineListDf(c(list(combinedDf), listDf[-(1:2)]))[[1]]
}
a
combineListDf(c(latentModelRca2$productIndicators, latentModelRca2$productIndicators)) ->a
a
# note this function might be slow for large df's, I might create a C++
# version of it
combineListDf <- function(listDf) {
# This function should work recursively
if (is.null(listDf)) {
return(NULL)
} else if (length(listDf) <= 1)  {
print(listDf)
return(listDf)
} else if (is.data.frame(listDf))  {
return(listDf)
}
print(length(listDf))
# Basecase combine the first two columns of the df
# check if there are matching colnames (the first df has priority)
matchingColnames <- colnames(listDf[[2]]) %in% colnames(listDf[[1]])
combinedDf <- cbind.data.frame(listDf[[1]], listDf[[2]][!matchingColnames])
combineListDf(c(list(combinedDf), listDf[-(1:2)]))
}
combineListDf(c(latentModelRca2$productIndicators, latentModelRca2$productIndicators)) ->a
a
is.data.frame(a)
View(a)
a[[1]]
# note this function might be slow for large df's, I might create a C++
# version of it
combineListDf <- function(listDf) {
# This function should work recursively
if (is.null(listDf)) {
return(NULL)
} else if (length(listDf) <= 1)  {
print(listDf)
return(listDf)
} else if (is.data.frame(listDf))  {
return(listDf)
}
print(length(listDf))
# Basecase combine the first two columns of the df
# check if there are matching colnames (the first df has priority)
matchingColnames <- colnames(listDf[[2]]) %in% colnames(listDf[[1]])
combinedDf <- cbind.data.frame(listDf[[1]], listDf[[2]][!matchingColnames])
out <- combineListDf(c(list(combinedDf), listDf[-(1:2)]))
out[[1]]
}
a[[1]]
combineListDf(c(latentModelRca2$productIndicators, latentModelRca2$productIndicators)) ->a
a
# note this function might be slow for large df's, I might create a C++
# version of it
combineListDf <- function(listDf) {
# This function should work recursively
if (is.null(listDf)) {
return(NULL)
} else if (length(listDf) <= 1)  {
print(listDf)
return(listDf)
} else if (is.data.frame(listDf))  {
return(listDf)
}
print(length(listDf))
# Basecase combine the first two columns of the df
# check if there are matching colnames (the first df has priority)
matchingColnames <- colnames(listDf[[2]]) %in% colnames(listDf[[1]])
combinedDf <- cbind.data.frame(listDf[[1]], listDf[[2]][!matchingColnames])
combineListDf(c(list(combinedDf), listDf[-(1:2)]))[1]
}
a
combineListDf(c(latentModelRca2$productIndicators, latentModelRca2$productIndicators)) ->a
a
# note this function might be slow for large df's, I might create a C++
# version of it
combineListDf <- function(listDf) {
# This function should work recursively
if (is.null(listDf)) {
return(NULL)
} else if (length(listDf) <= 1)  {
print(listDf)
return(listDf)
} else if (is.data.frame(listDf))  {
return(listDf)
}
print(length(listDf))
# Basecase combine the first two columns of the df
# check if there are matching colnames (the first df has priority)
matchingColnames <- colnames(listDf[[2]]) %in% colnames(listDf[[1]])
combinedDf <- cbind.data.frame(listDf[[1]], listDf[[2]][!matchingColnames])
combineListDf(c(list(combinedDf), listDf[-(1:2)]))[1][[1]]
}
combineListDf(c(latentModelRca2$productIndicators, latentModelRca2$productIndicators)) ->a
a
# note this function might be slow for large df's, I might create a C++
# version of it
combineListDf <- function(listDf) {
# This function should work recursively
if (is.null(listDf)) {
return(NULL)
} else if (length(listDf) <= 1)  {
print(listDf)
return(listDf)
} else if (is.data.frame(listDf))  {
return(listDf)
}
print(length(listDf))
# Basecase combine the first two columns of the df
# check if there are matching colnames (the first df has priority)
matchingColnames <- colnames(listDf[[2]]) %in% colnames(listDf[[1]])
combinedDf <- cbind.data.frame(listDf[[1]], listDf[[2]][!matchingColnames])
as.data.frame(combineListDf(c(list(combinedDf), listDf[-(1:2)])))
}
combineListDf(c(latentModelRca2$productIndicators, latentModelRca2$productIndicators)) ->a
combineListDf(c(latentModelRca2$productIndicators, latentModelRca2$productIndicators)) ->a
a
combineListDf(c(latentModelRca2$productIndicators, latentModelRca2$productIndicators)) ->a
# note this function might be slow for large df's, I might create a C++
# version of it
combineListDf <- function(listDf) {
# This function should work recursively
if (is.null(listDf)) {
return(NULL)
} else if (length(listDf) <= 1)  {
print(listDf)
return(listDf)
} else if (is.data.frame(listDf))  {
return(listDf)
}
print(length(listDf))
# Basecase combine the first two columns of the df
# check if there are matching colnames (the first df has priority)
matchingColnames <- colnames(listDf[[2]]) %in% colnames(listDf[[1]])
combinedDf <- cbind.data.frame(listDf[[1]], listDf[[2]][!matchingColnames])
structure(combineListDf(c(list(combinedDf), listDf[-(1:2)])),
class = "data.frame")
}
combineListDf(c(latentModelRca2$productIndicators, latentModelRca2$productIndicators)) ->a
a
c(list(iris), list())
# note this function might be slow for large df's, I might create a C++
# version of it
combineListDf <- function(listDf) {
# This function should work recursively
if (is.null(listDf)) {
return(NULL)
} else if (length(listDf) <= 1)  {
print(listDf)
return(listDf[[1]])
} else if (is.data.frame(listDf))  {
return(listDf)
}
print(length(listDf))
# Basecase combine the first two columns of the df
# check if there are matching colnames (the first df has priority)
matchingColnames <- colnames(listDf[[2]]) %in% colnames(listDf[[1]])
combinedDf <- cbind.data.frame(listDf[[1]], listDf[[2]][!matchingColnames])
combineListDf(c(list(combinedDf), listDf[-(1:2)]))
}
combineListDf(c(latentModelRca2$productIndicators, latentModelRca2$productIndicators)) ->a
a
a <- "helo"
"hella {a}"
a
warning(a)
warning(a, "hello")
warning("hello", 1:10)
warning("hello", cat(1:10))
help(warning)
warning("hello\n", cat(1:10))
warning("hello\n", 1:10)
# note this function might be slow for large df's, I might create a C++
# version of it
combineListDf <- function(listDf) {
# This function should work recursively
if (is.null(listDf)) {
return(NULL)
} else if (length(listDf) <= 1)  {
return(listDf[[1]])
# This shouldnt really be necessary, but in the case that the function
# recieves a dataframe, we should just return it
} else if (is.data.frame(listDf))  {
return(listDf)
}
# Basecase combine the first two columns of the df
# check if there are matching colnames (the first df has priority)
matchingColnames <- colnames(listDf[[2]]) %in% colnames(listDf[[1]])
if (sum(as.integer(matchingColnames)) > 0) {
duplicates <- stringr::str_c(colnames(listDf[[2]])[matchingColnames],
collapse = " ,")
warning2("Duplicate indicator products were removed: \n",
duplicates)
}
combinedDf <- cbind.data.frame(listDf[[1]], listDf[[2]][!matchingColnames])
combineListDf(c(list(combinedDf), listDf[-(1:2)]))
}
combineListDf(list(iris iris))
combineListDf(list(iris, iris))
# note this function might be slow for large df's, I might create a C++
# version of it
combineListDf <- function(listDf) {
# This function should work recursively
if (is.null(listDf)) {
return(NULL)
} else if (length(listDf) <= 1)  {
return(listDf[[1]])
# This shouldnt really be necessary, but in the case that the function
# recieves a dataframe, we should just return it
} else if (is.data.frame(listDf))  {
return(listDf)
}
# Basecase combine the first two columns of the df
# check if there are matching colnames (the first df has priority)
matchingColnames <- colnames(listDf[[2]]) %in% colnames(listDf[[1]])
if (sum(as.integer(matchingColnames)) > 0) {
duplicates <- stringr::str_c(colnames(listDf[[2]])[matchingColnames],
collapse = ", ")
warning2("Duplicate indicator products were removed: \n",
duplicates)
}
combinedDf <- cbind.data.frame(listDf[[1]], listDf[[2]][!matchingColnames])
combineListDf(c(list(combinedDf), listDf[-(1:2)]))
}
combineListDf(list(iris, iris))
library(modsem)
m1 <- '
# Outer Model
X =~ x1 + x2 +x3
Y =~ y1 + y2 + y3
Z =~ z1 + z2 + z3
# Inner model
Y ~ X + Z + X:Z
'
realModel <- lm(realY ~ realX*realZ, df1)
summary(realModel)
library(lavaan)
library(modsem)
setwd("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/data")
df1 <- readRDS("exampleData1.rds")
df2 <- readRDS("exampleData4.rds")
df3 <- readRDS("exampleData3.rds")
latentModelRca <- modsem(m1, df1, method = "rca")
lavaan::summary(latentModelRca$lavaan)
summary(latentModelRca)
summary.modsem(latentModelRca)
latentModelUncent <- modsem(m1, df1, method = "unconstrained")
lavaan::summary(latentModelUncent$lavaan)
m2 <- '
# Outer Model
X =~ x1 + x2 +x3
Y =~ y1 + y2 + y3
Z =~ z1 + z2 + z3
G =~ g1 + g2 + g3 + x1
H =~ h1 + h2 + h3 + z1
# Inner model
Y ~ X + Z + G + H + X:Z + G:H
'
realModel2 <- lm(realY ~ realX*realZ + realG*realH, df2)
summary(realModel2)
m2 <- '
# Outer Model
X =~ x1 + x2 +x3
Y =~ y1 + y2 + y3
Z =~ z1 + z2 + z3
G =~ g1 + g2 + g3 + x1
H =~ h1 + h2 + h3 + z1
# Inner model
Y ~ X + Z + G + H + X:Z + G:H
'
latentModelRca2 <- modsem(m2, df2, method = "rca")
lavaan::summary(latentModelRca2$lavaan)
m2 <- '
# Outer Model
X =~ x1 + x2 +x3
Y =~ y1 + y2 + y3
Z =~ z1 + z2 + z3
G =~ g1 + g2 + g3
H =~ h1 + h2 + h3
# Inner model
Y ~ X + Z + G + H + X:Z + G:H
'
latentModelRca2 <- modsem(m2, df2, method = "rca")
lavaan::summary(latentModelRca2$lavaan)
# note this function might be slow for large df's, I might create a C++
# version of it
combineListDf <- function(listDf) {
# This function should work recursively
if (is.null(listDf)) {
return(NULL)
} else if (length(listDf) <= 1)  {
return(listDf[[1]])
# This shouldnt really be necessary, but in the case that the function
# recieves a dataframe, we should just return it
} else if (is.data.frame(listDf))  {
return(listDf)
}
# Basecase combine the first two columns of the df
# check if there are matching colnames (the first df has priority)
matchingColnames <- colnames(listDf[[2]]) %in% colnames(listDf[[1]])
if (sum(as.integer(matchingColnames)) > 0) {
duplicates <- stringr::str_c(colnames(listDf[[2]])[matchingColnames],
collapse = ", ")
warning2(
"There were some duplicate product indicators, was this intended?\n",
"The duplicates of these product indicators were removed: \n",
duplicates, "\n")
}
combinedDf <- cbind.data.frame(listDf[[1]], listDf[[2]][!matchingColnames])
combineListDf(c(list(combinedDf), listDf[-(1:2)]))
}
help(MethodAddCoerce)
summary.modsem(latentModelRca2)
summary(latentModelRca2)
source("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/modsem/R/modsem2.1.R", echo=TRUE)
library(modsem)
summary(latentModelRca)
library(lavaan)
library(modsem)
setwd("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/data")
df1 <- readRDS("exampleData1.rds")
df2 <- readRDS("exampleData4.rds")
df3 <- readRDS("exampleData3.rds")
latentModelRca <- modsem(m1, df1, method = "rca")
m1 <- '
# Outer Model
X =~ x1 + x2 +x3
Y =~ y1 + y2 + y3
Z =~ z1 + z2 + z3
# Inner model
Y ~ X + Z + X:Z
'
realModel <- lm(realY ~ realX*realZ, df1)
summary(realModel)
latentModelRca <- modsem(m1, df1, method = "rca")
lavaan::summary(latentModelRca$lavaan)
summary(latentModelRca)
summary.modsem(latentModelRca)
summary(latentModelRca)
class(latentModelRca)
attributes(latentModelRca)
methods(summary)
?methods
help("setMethod")
cat("hello", "there")
#' @rdname summary
#' @export
summary.modsem <- function(object, ...) {
cat("ModSEM: \nMethod =", attributes(object)$method)
lavaan::summary(object$lavaan)
}
summary.modsem(latentModelRca)
#' @rdname summary
#' @export
summary.modsem <- function(object, ...) {
cat("ModSEM: \nMethod =", attributes(object)$method, "\n")
lavaan::summary(object$lavaan)
}
summary.modsem(latentModelRca)
document()
devtools::document()
source("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/modsem/R/modsem2.1.R", echo=TRUE)
devtools::document()
warnings()
devtools::document()
warnings()
devtools::document()
library(modsem)
devtools::document()
library(lavaan)
library(modsem)
setwd("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/data")
df1 <- readRDS("exampleData1.rds")
df2 <- readRDS("exampleData4.rds")
df3 <- readRDS("exampleData3.rds")
m1 <- '
# Outer Model
X =~ x1 + x2 +x3
Y =~ y1 + y2 + y3
Z =~ z1 + z2 + z3
# Inner model
Y ~ X + Z + X:Z
'
realModel <- lm(realY ~ realX*realZ, df1)
summary(realModel)
latentModelRca <- modsem(m1, df1, method = "rca")
#lavaan::summary(latentModelRca$lavaan)
summary(latentModelRca)
#summary.modsem(latentModelRca)
library(devtools)
library(roxygen2)
library(lavaan)
library(modsem)
setwd("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/data")
df1 <- readRDS("exampleData1.rds")
df2 <- readRDS("exampleData4.rds")
df3 <- readRDS("exampleData3.rds")
m1 <- '
# Outer Model
X =~ x1 + x2 +x3
Y =~ y1 + y2 + y3
Z =~ z1 + z2 + z3
# Inner model
Y ~ X + Z + X:Z
'
realModel <- lm(realY ~ realX*realZ, df1)
summary(realModel)
latentModelRca <- modsem(m1, df1, method = "rca")
#lavaan::summary(latentModelRca$lavaan)
summary(latentModelRca)
#summary.modsem(latentModelRca)
unfinished <- '
# Outer Model
X =~ x1 + x2 + x3
Y =~ y1 + y2 + y3
# Inner model
Y ~ X + Z
'
finished <-'
# Outer Model
X =~ x1 + x2 + x3
Y =~ y1 + y2 + y3
Z =~ z1 + z2 + z3
# Inner model
Y ~ X + Z
'
lavaanify(stringr::str_remove_all(unfinished, ":")) -> unfinishedLavan
lavaanify(stringr::str_remove_all(finished, ":")) -> finishedLavan
m2 <- '
# Outer Model
X =~ x1 + x2 +x3
Y =~ y1 + y2 + y3
Z =~ z1 + z2 + z3
G =~ g1 + g2 + g3
H =~ h1 + h2 + h3
# Inner model
Y ~ X + Z + G + H + X:Z + G:H
'
realModel2 <- lm(realY ~ realX*realZ + realG*realH, df2)
summary(realModel2)
m2 <- '
# Outer Model
X =~ x1 + x2 +x3
Y =~ y1 + y2 + y3
Z =~ z1 + z2 + z3
G =~ g1 + g2 + g3
H =~ h1 + h2 + h3
# Inner model
Y ~ X + Z + G + H + X:Z + G:H
'
latentModelRca2 <- modsem(m2, df2, method = "rca")
modsem(latentModelRca2)
df2
m2 <- '
# Outer Model
X =~ x1 + x2 +x3
Y =~ y1 + y2 + y3
Z =~ z1 + z2 + z3
G =~ g1 + g2 + g3
H =~ h1 + h2 + h3
# Inner model
Y ~ X + Z + G + H + X:Z + G:H
'
latentModelRca2 <- modsem(m2, df2, method = "rca")
modsem(latentModelRca2)
m2 <- '
# Outer Model
X =~ x1 + x2 +x3
Y =~ y1 + y2 + y3
Z =~ z1 + z2 + z3
G =~ g1 + g2 + g3
H =~ h1 + h2 + h3
# Inner model
Y ~ X + Z + G + H + X:Z + G:H
'
latentModelRca2 <- modsem(m2, df2, method = "rca")
summary(latentModelRca2)
cat(latentModelRca2$newSyntax)
latentModelUnc <- modsem(m1, df1, method = "unconstrained")
summary(latentModelUnc)
latentModelRegApp <- modsem(m1, df1, method = "regression")
summary(latentModelRegApp)
regModel <- '
y1 ~ x1 + z1 + x1z1
'
df1Mod <- df1
df1Mod$x1z1 <- df1$x1*df1$z1
sem(regModel, df1Mod) -> simple
summary(simple)
lm(y1 ~ x1 + z1 + x1z1, df1)
lm(y1 ~ x1*z1, df1)
regModelModsem <- '
y1 ~ x1 + z1 + x1:z1
'
m4 <- modsem(regModelModsem, df1, method = "regression")
summary(m4)
help(modsem)
library(modsem)
help(modsem)
