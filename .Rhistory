products
}
modsem(testModel, testData) -> spec
createIndicatorProducts <- function(relationMatrix, data, centered = TRUE) {
# Getting the indicatorProduct names
varnames <- colnames(relationMatrix)
# Getting all indicatornames used to create the products
allIndicatorNames <- relationMatrix |>
unlist() |>
unname() |>
unique()
print(allIndicatorNames)
# Getting a dataframe with all the indiactors and their values
indicators <- data[allIndicatorNames]
# Centering them, if center == TRUE
if (centered == TRUE) {
indicators <- apply(indicators, 2, scale, scale = FALSE) |>
as.data.frame()
}
# Creating a dataframe to hold the computed indicatorproducts
products <- data.frame(matrix(ncol = length(varnames), nrow = nrow(data)))
# Setting the productames (e.g., var1var2 = var1*var2)
colnames(products) <- varnames
# Loop to create the indicatorProducts
for (i in seq_along(varnames)) {
varname <- varnames[[i]]
products[[varname]] <- multiplyIndicators(indicators[relationMatrix[[varname]]])
}
products
}
spec$productIndicators
apply(spec$productIndicators, 1, mean)
apply(spec$productIndicators, 2, mean)
apply(spec$productIndicators$XZ, 2, mean)
createIndicatorProducts <- function(relationMatrix, data, centered = TRUE) {
# Getting the indicatorProduct names
varnames <- colnames(relationMatrix)
# Getting all indicatornames used to create the products
allIndicatorNames <- relationMatrix |>
unlist() |>
unname() |>
unique()
print(allIndicatorNames)
# Getting a dataframe with all the indiactors and their values
indicators <- data[allIndicatorNames]
# Centering them, if center == TRUE
if (centered == TRUE) {
indicators <- apply(indicators, 2, scale, scale = FALSE) |>
as.data.frame()
}
print(apply(indicators, 2, mean))
# Creating a dataframe to hold the computed indicatorproducts
products <- data.frame(matrix(ncol = length(varnames), nrow = nrow(data)))
# Setting the productames (e.g., var1var2 = var1*var2)
colnames(products) <- varnames
# Loop to create the indicatorProducts
for (i in seq_along(varnames)) {
varname <- varnames[[i]]
products[[varname]] <- multiplyIndicators(indicators[relationMatrix[[varname]]])
}
products
}
modsem(testModel, testData)
modsem(testModel, testData) -> spec
createIndicatorProducts <- function(relationMatrix, data, centered = FALSE) {
# Getting the indicatorProduct names
varnames <- colnames(relationMatrix)
# Getting all indicatornames used to create the products
allIndicatorNames <- relationMatrix |>
unlist() |>
unname() |>
unique()
# Getting a dataframe with all the indiactors and their values
indicators <- data[allIndicatorNames]
# Centering them, if center == TRUE
if (centered == TRUE) {
indicators <- apply(indicators, 2, scale, scale = FALSE) |>
as.data.frame()
}
print(apply(indicators, 2, mean))
# Creating a dataframe to hold the computed indicatorproducts
products <- data.frame(matrix(ncol = length(varnames), nrow = nrow(data)))
# Setting the productames (e.g., var1var2 = var1*var2)
colnames(products) <- varnames
# Loop to create the indicatorProducts
for (i in seq_along(varnames)) {
varname <- varnames[[i]]
products[[varname]] <- multiplyIndicators(indicators[relationMatrix[[varname]]])
}
products
}
modsem(testModel, testData) -> spec
createIndicatorProducts <- function(relationMatrix, data, centered = FALSE) {
# Getting the indicatorProduct names
varnames <- colnames(relationMatrix)
# Getting all indicatornames used to create the products
allIndicatorNames <- relationMatrix |>
unlist() |>
unname() |>
unique()
# Getting a dataframe with all the indiactors and their values
indicators <- data[allIndicatorNames]
# Centering them, if center == TRUE
if (centered == TRUE) {
indicators <- apply(indicators, 2, scale, scale = FALSE) |>
as.data.frame()
}
# Creating a dataframe to hold the computed indicatorproducts
products <- data.frame(matrix(ncol = length(varnames), nrow = nrow(data)))
# Setting the productames (e.g., var1var2 = var1*var2)
colnames(products) <- varnames
# Loop to create the indicatorProducts
for (i in seq_along(varnames)) {
varname <- varnames[[i]]
products[[varname]] <- multiplyIndicators(indicators[relationMatrix[[varname]]])
}
products
}
createProductIndicators.rca <- function(modelSpecification) {
# Compute indicatorProducts (wihtout centering the variables)
indicatorProducts <- lapply(modelSpecification$relationMatrix, createIndicatorProducts, modelSpecification$data,
centered = FALSE)
}
createProductIndicators.rca <- function(modelSpecification, ...) {
# Compute indicatorProducts (wihtout centering the variables)
indicatorProducts <- lapply(modelSpecification$relationMatrix, createIndicatorProducts, modelSpecification$data,
centered = FALSE)
}
createProductIndicators.rca <- function(modelSpecification, ...) {
# Compute indicatorProducts (wihtout centering the variables)
indicatorProducts <- lapply(modelSpecification$relationMatrix, createIndicatorProducts, modelSpecification$data,
centered = FALSE)
}
createIndicatorProducts <- function(relationMatrix, data, centered = FALSE) {
# Getting the indicatorProduct names
varnames <- colnames(relationMatrix)
# Getting all indicatornames used to create the products
allIndicatorNames <- relationMatrix |>
unlist() |>
unname() |>
unique()
# Getting a dataframe with all the indiactors and their values
indicators <- data[allIndicatorNames]
# Centering them, if center == TRUE
if (centered == TRUE) {
indicators <- apply(indicators, 2, scale, scale = FALSE) |>
as.data.frame()
}
print(apply(indicators, 2, mean))
# Creating a dataframe to hold the computed indicatorproducts
products <- data.frame(matrix(ncol = length(varnames), nrow = nrow(data)))
# Setting the productames (e.g., var1var2 = var1*var2)
colnames(products) <- varnames
# Loop to create the indicatorProducts
for (i in seq_along(varnames)) {
varname <- varnames[[i]]
products[[varname]] <- multiplyIndicators(indicators[relationMatrix[[varname]]])
}
products
}
modsem(testModel, testData, centered = TRUE) -> spec
modsem(testModel, testData, centered = FALSE) -> spec
modsem <- function(modelSyntax,
data,
method = "rca",
specifyCovs = TRUE,
firstFixed = TRUE ,
...) {
# Get the specifications of the model
modelSpecification <- createModelSpecification(modelSyntax, data, method = method, ...)
modelSpecification
}
modsem(testModel, testData, centered = TRUE) -> spec
createProductIndicators.rca <- function(modelSpecification, ...) {
# Compute indicatorProducts (wihtout centering the variables)
indicatorProducts <- lapply(modelSpecification$relationMatrix, createIndicatorProducts, modelSpecification$data,
...)
}
modsem(testModel, testData, centered = TRUE) -> spec
getProductIndicators(example3)
lapply(getProductIndicators(example3), unlist)
getIndividualIndicators <- function(modelSyntax) {
# List with vectors
# Example:
indicators <- getProductIndicators(modelSyntax)
lapply(indicators, function(x) unname(unlist(x)))
}
getIndividualIndicators(example3)
createModelSpecification <- function(modelSyntax, data, method = "rca") {
modelSpecification <- list(
originalSyntax = modelSyntax,
# I might not need these two, since relationIndicatorLatentCombo contains the same info
# productCombos = createProductCombos(modelSyntax),
# indicatorProductNames = createIndicatorNames(modelSyntax),
indicatorNamesLatentProducts = getIndividualIndicators(modelSyntax),
# This is a combination of the two above:
# I definetely need a shorter word for this
relationMatrix = relationIndicatorLatentCombo(modelSyntax),
data = data
)
# setting class to method used
class(modelSpecification) <- method
# computing the productindicators based on class/method
modelSpecification$productIndicators <- createProductIndicators(modelSpecification)
# returning object
modelSpecification
}
createModelSpecification <- function(modelSyntax, data, method = "rca") {
modelSpecification <- list(
originalSyntax = modelSyntax,
# I might not need these two, since relationIndicatorLatentCombo contains the same info
# productCombos = createProductCombos(modelSyntax),
# indicatorProductNames = createIndicatorNames(modelSyntax),
indicatorNames = getIndividualIndicators(modelSyntax),
# This is a combination of the two above:
# I definetely need a shorter word for this
relationMatrix = relationIndicatorLatentCombo(modelSyntax),
data = data
)
# setting class to method used
class(modelSpecification) <- method
# computing the productindicators based on class/method
modelSpecification$productIndicators <- createProductIndicators(modelSpecification)
# returning object
modelSpecification
}
formals(createIndicatorProducts)
createIndicatorProducts <- function(relationMatrix, indicatorNames, data, centered = FALSE) {
# Getting the indicatorProduct names
varnames <- colnames(relationMatrix)
# Getting a dataframe with all the indiactors and their values
indicators <- data[indicatorNames]
# Centering them, if center == TRUE
if (centered == TRUE) {
indicators <- apply(indicators, 2, scale, scale = FALSE) |>
as.data.frame()
}
# jUST FOR TESTING
print(apply(indicators, 2, mean))
# Creating a dataframe to hold the computed indicatorproducts
products <- data.frame(matrix(ncol = length(varnames), nrow = nrow(data)))
# Setting the productames (e.g., var1var2 = var1*var2)
colnames(products) <- varnames
# Loop to create the indicatorProducts
for (i in seq_along(varnames)) {
varname <- varnames[[i]]
products[[varname]] <- multiplyIndicators(indicators[relationMatrix[[varname]]])
}
products
}
formals(createIndicatorProducts)
createProductIndicators.rca <- function(modelSpecification, ...) {
# Compute indicatorProducts (wihtout centering the variables)
indicatorProducts <- lapply(relationMatrix, createIndicatorProducts,
indicatorNames = modelSpecification$indicatorNames,
data = modelSpecification$data,
centered = FALSE)
}
modsem(testModel, testData, centered = TRUE) -> spec
modsem(testModel, testData) -> spec
createProductIndicators.rca <- function(modelSpecification, ...) {
# Compute indicatorProducts (wihtout centering the variables)
indicatorProducts <- lapply(modelSpecification$relationMatrix, createIndicatorProducts,
indicatorNames = modelSpecification$indicatorNames,
data = modelSpecification$data,
centered = FALSE)
}
modsem(testModel, testData) -> spec
createIndicatorProducts <- function(modelSpecification, centered = FALSE) {
relationMatrix <- modelSpecification$relationMatrix
indicatorNames <- modelSpecification$indicatorNames
data <- modelSpecification$data
# Getting the indicatorProduct names
varnames <- colnames(relationMatrix)
# Getting a dataframe with all the indiactors and their values
indicators <- data[indicatorNames]
# Centering them, if center == TRUE
if (centered == TRUE) {
indicators <- apply(indicators, 2, scale, scale = FALSE) |>
as.data.frame()
}
# jUST FOR TESTING
print(apply(indicators, 2, mean))
# Creating a dataframe to hold the computed indicatorproducts
products <- data.frame(matrix(ncol = length(varnames), nrow = nrow(data)))
# Setting the productames (e.g., var1var2 = var1*var2)
colnames(products) <- varnames
# Loop to create the indicatorProducts
for (i in seq_along(varnames)) {
varname <- varnames[[i]]
products[[varname]] <- multiplyIndicators(indicators[relationMatrix[[varname]]])
}
products
}
modsem(testModel, testData) -> spec
createIndicatorProducts <- function(modelSpecification, centered = FALSE) {
relationMatrix <- modelSpecification$relationMatrix
indicatorNames <- modelSpecification$indicatorNames
data <- modelSpecification$data
# Getting the indicatorProduct names
varnames <- colnames(relationMatrix)
# Getting a dataframe with all the indiactors and their values
indicators <- data[indicatorNames]
# Centering them, if center == TRUE
if (centered == TRUE) {
indicators <- apply(indicators, 2, scale, scale = FALSE) |>
as.data.frame()
}
# jUST FOR TESTING
print(apply(indicators, 2, mean))
# Creating a dataframe to hold the computed indicatorproducts
products <- data.frame(matrix(ncol = length(varnames), nrow = nrow(data)))
# Setting the productames (e.g., var1var2 = var1*var2)
colnames(products) <- varnames
# Loop to create the indicatorProducts
for (i in seq_along(varnames)) {
varname <- varnames[[i]]
products[[varname]] <- multiplyIndicators(indicators[relationMatrix[[varname]]])
}
products
}
createProductIndicators.rca <- function(modelSpecification, ...) {
# Compute indicatorProducts (wihtout centering the variables)
indicatorProducts <- lapply(modelSpecification, createIndicatorProducts, centered = FALSE)
}
modsem(testModel, testData) -> spec
source("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/modsem/R/buildModelSpecification.R", echo=TRUE)
source("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/modsem/R/rca.R", echo=TRUE)
modsem(testModel, testData) -> spec
library(modsem)
library(lavaan)
library(modsem)
setwd("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/data")
df1 <- readRDS("exampleData1.rds")
df2 <- readRDS("exampleData4.rds")
df3 <- readRDS("exampleData3.rds")
s1 <- '
# outer Model
Attitude =~ ATTD1 + ATTD2 + ATTD4 + ATTD4
PBC =~ PBC1 + PBC2 + PBC3 + PBC4
Behaviour =~ PB1 + PB2 + PB3 + PB4
SN =~ SN1 + SN2 + SN3 + SN4
pestY =~ ty1 + ty2
TestX =~ tx1 + tx2
# Higher order
Intention =~ PBC + SN + Attitude
# Inner model
Behaviour ~ Intention + PBC + Intention:PBC + pestY :TestX
Behaviour ~ Intention + PBC + pestY :TestX
'
readS1 <- readModsem(s1)
cat(readS1$modifiedSyntax)
latentModelUncent <- modsem(m1, df1, method = "unconstrained")
m1 <- '
# Outer Model
X =~ x1 + x2 +x3
Y =~ y1 + y2 + y3
Z =~ z1 + z2 + z3
# Inner model
Y ~ X + Z + X:Z
'
realModel <- lm(realY ~ realX*realZ, df1)
summary(realModel)
latentModelUncent <- modsem(m1, df1, method = "unconstrained")
source("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/modsem/R/unrestricted.R", echo=TRUE)
latentModelUncent <- modsem(m1, df1, method = "unconstrained")
lavaan::summary(latentModelUncent$lavaan)
library(modsem)
library(lavaan)
library(modsem)
setwd("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/data")
df1 <- readRDS("exampleData1.rds")
df2 <- readRDS("exampleData4.rds")
df3 <- readRDS("exampleData3.rds")
library(lavaan)
library(modsem)
setwd("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/data")
df1 <- readRDS("exampleData1.rds")
df2 <- readRDS("exampleData4.rds")
df3 <- readRDS("exampleData3.rds")
m1 <- '
# Outer Model
X =~ x1 + x2 +x3
Y =~ y1 + y2 + y3
Z =~ z1 + z2 + z3
# Inner model
Y ~ X + Z + X:Z
'
realModel <- lm(realY ~ realX*realZ, df1)
summary(realModel)
latentModelUncent <- modsem(m1, df1, method = "unconstrained")
lavaan::summary(latentModelUncent$lavaan)
latentModelUncent <- modsem(m1, df1, method = "unconstrained")
latentModelRca <- modsem(m1, df1, method = "rca")
latentModelRca <- modsem(m1, df1, method = "rca")
lavaan::summary(latentModelRca$lavaan)
library(lavaan)
library(modsem)
setwd("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/data")
df1 <- readRDS("exampleData1.rds")
df2 <- readRDS("exampleData4.rds")
df3 <- readRDS("exampleData3.rds")
latentModelRca <- modsem(m1, df1, method = "rca")
lavaan::summary(latentModelRca$lavaan)
df1 <- apply(scale, 2, df1)
df1 <- apply(df1, 2, scale)
realModel <- lm(realY ~ realX*realZ, df1)
summary(realModel)
realModel <- lm(realY ~ realX*realZ, df1)
df1 <- as.data.frame(apply(df1, 2, scale))
realModel <- lm(realY ~ realX*realZ, df1)
summary(realModel)
df1 <- as.data.frame(apply(df1, 2, scale, scale = FALSE))
realModel <- lm(realY ~ realX*realZ, df1)
summary(realModel)
m1 <- '
# Outer Model
X =~ x1 + x2 +x3
Y =~ y1 + y2 + y3
Z =~ z1 + z2 + z3
# Inner model
Y ~ X + Z + X:Z
'
realModel <- lm(realY ~ realX*realZ, df1)
summary(realModel)
latentModelUncent <- modsem(m1, df1, method = "unconstrained")
lavaan::summary(latentModelUncent$lavaan)
latentModelRca <- modsem(m1, df1, method = "rca")
lavaan::summary(latentModelRca$lavaan)
m2 <- '
# Outer Model
X =~ x1 + x2 +x3
Y =~ y1 + y2 + y3
Z =~ z1 + z2 + z3
G =~ g1 + g2 + g3
H =~ h1 + h2 + h3
# Inner model
Y ~ X + Z + G + H + X:Z + G:H
'
realModel2 <- lm(realY ~ realX*realZ + realG*realH, df2)
summary(realModel2)
m2 <- '
# Outer Model
X =~ x1 + x2 +x3
Y =~ y1 + y2 + y3
Z =~ z1 + z2 + z3
G =~ g1 + g2 + g3
H =~ h1 + h2 + h3
# Inner model
Y ~ X + Z + G + H + X:Z + G:H
'
latentModelRca2 <- modsem(m2, df2, method = "rca")
lavaan::summary(latentModelRca2$lavaan)
pprint::psummary(realModel2, std.beta = TRUE)
pprint::psummary(realModel2, std_beta = TRUE)
pprint::psummary(realModel2, std_beta = TRUE)
pprint::psummary(realModel2, std_beta = TRUE)
latentModelUncent2 <- modsem(m2, df2, method = "unconstrained")
lavaan::summary(latentModelUncent2$lavaan)
m3 <- '
# Outer Model
X =~ x1 + x2 +x3
Y =~ y1 + y2 + y3
Z =~ z1 + z2 + z3
# Inner model
Y ~ X + Z + X:Z
'
realModel <- lm(realY ~ realX*realZ, df3)
summary(realModel)
latentModelRca3 <- modsem(m3, df3, method = "rca")
lavaan::summary(latentModelRca3$lavaan)
latentModelUncent <- modsem(m3, df3, method = "unconstrained")
lavaan::summary(latentModelUncent$lavaan)
m2 <- '
# Outer Model
X =~ x1 + x2 +x3
Y =~ y1 + y2 + y3
Z =~ z1 + z2 + z3
G =~ 1*g1
H =~ 1*h1
# Inner model
Y ~ X + Z + G + H + X:Z + G:H
'
realModel2 <- lm(realY ~ realX*realZ + realG*realH, df2)
summary(realModel2, lm.beta)
m2 <- '
# Outer Model
X =~ x1 + x2 +x3
Y =~ y1 + y2 + y3
Z =~ z1 + z2 + z3
G =~ 1*g1
H =~ 1*h1
# Inner model
Y ~ X + Z + G + H + X:Z + G:H
'
latentModelRca2 <- modsem(m2, df2, method = "rca")
m2 <- '
# Outer Model
X =~ x1 + x2 +x3
Y =~ y1 + y2 + y3
Z =~ z1 + z2 + z3
G =~ g1
H =~ h1
# Inner model
Y ~ X + Z + G + H + X:Z + G:H
'
latentModelRca2 <- modsem(m2, df2, method = "rca")
lavaan::summary(latentModelRca2$lavaan)
realModel2 <- lm(realY ~ realX*realZ + h1*g1, df2)
summary(realModel2)
latentModelUncent2 <- modsem(m2, df2, method = "unconstrained")
lavaan::summary(latentModelUncent2$lavaan)
