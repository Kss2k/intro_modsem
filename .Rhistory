if (centered == TRUE) {
indicators <- apply(indicators, 2, scale, scale = FALSE)
}
# Creating a dataframe to hold the computed indicatorproducts
products <- data.frame(matrix(ncol = length(varnames), nrow = nrow(data)))
# Setting the productames (e.g., var1var2 = var1*var2)
colnames(products) <- varnames
# Loop to create the indicatorProducts
for (i in seq_along(varnames)) {
varname <- varnames[[i]]
products[[varname]] <- multiplyIndicators(indicators[relationMatrix[[varname]]])
}
products
}
modsem(testModel, testData) -> spec
createIndicatorProducts <- function(relationMatrix, data, centered = TRUE) {
# Getting the indicatorProduct names
varnames <- colnames(relationMatrix)
# Getting all indicatornames used to create the products
allIndicatorNames <- relationMatrix |>
unlist() |>
unname() |>
unique()
print(allIndicatorNames)
# Getting a dataframe with all the indiactors and their values
indicators <- data[allIndicatorNames]
# Centering them, if center == TRUE
if (centered == TRUE) {
indicators <- apply(indicators, 2, scale, scale = FALSE)
}
print(indiactors)
# Creating a dataframe to hold the computed indicatorproducts
products <- data.frame(matrix(ncol = length(varnames), nrow = nrow(data)))
# Setting the productames (e.g., var1var2 = var1*var2)
colnames(products) <- varnames
# Loop to create the indicatorProducts
for (i in seq_along(varnames)) {
varname <- varnames[[i]]
products[[varname]] <- multiplyIndicators(indicators[relationMatrix[[varname]]])
}
products
}
modsem(testModel, testData) -> spec
createIndicatorProducts <- function(relationMatrix, data, centered = TRUE) {
# Getting the indicatorProduct names
varnames <- colnames(relationMatrix)
# Getting all indicatornames used to create the products
allIndicatorNames <- relationMatrix |>
unlist() |>
unname() |>
unique()
print(allIndicatorNames)
# Getting a dataframe with all the indiactors and their values
indicators <- data[allIndicatorNames]
# Centering them, if center == TRUE
if (centered == TRUE) {
indicators <- apply(indicators, 2, scale, scale = FALSE)
}
print(indicators)
# Creating a dataframe to hold the computed indicatorproducts
products <- data.frame(matrix(ncol = length(varnames), nrow = nrow(data)))
# Setting the productames (e.g., var1var2 = var1*var2)
colnames(products) <- varnames
# Loop to create the indicatorProducts
for (i in seq_along(varnames)) {
varname <- varnames[[i]]
products[[varname]] <- multiplyIndicators(indicators[relationMatrix[[varname]]])
}
products
}
modsem(testModel, testData) -> spec
createIndicatorProducts <- function(relationMatrix, data, centered = TRUE) {
# Getting the indicatorProduct names
varnames <- colnames(relationMatrix)
# Getting all indicatornames used to create the products
allIndicatorNames <- relationMatrix |>
unlist() |>
unname() |>
unique()
print(allIndicatorNames)
# Getting a dataframe with all the indiactors and their values
indicators <- data[allIndicatorNames, , drop = FALSE]
# Centering them, if center == TRUE
if (centered == TRUE) {
indicators <- apply(indicators, 2, scale, scale = FALSE)
}
print(indicators)
# Creating a dataframe to hold the computed indicatorproducts
products <- data.frame(matrix(ncol = length(varnames), nrow = nrow(data)))
# Setting the productames (e.g., var1var2 = var1*var2)
colnames(products) <- varnames
# Loop to create the indicatorProducts
for (i in seq_along(varnames)) {
varname <- varnames[[i]]
products[[varname]] <- multiplyIndicators(indicators[relationMatrix[[varname]]])
}
products
}
modsem(testModel, testData) -> spec
createIndicatorProducts <- function(relationMatrix, data, centered = TRUE) {
# Getting the indicatorProduct names
varnames <- colnames(relationMatrix)
# Getting all indicatornames used to create the products
allIndicatorNames <- relationMatrix |>
unlist() |>
unname() |>
unique()
print(allIndicatorNames)
# Getting a dataframe with all the indiactors and their values
indicators <- data[allIndicatorNames] |>
as.data.frame()
# Centering them, if center == TRUE
if (centered == TRUE) {
indicators <- apply(indicators, 2, scale, scale = FALSE)
}
print(indicators)
# Creating a dataframe to hold the computed indicatorproducts
products <- data.frame(matrix(ncol = length(varnames), nrow = nrow(data)))
# Setting the productames (e.g., var1var2 = var1*var2)
colnames(products) <- varnames
# Loop to create the indicatorProducts
for (i in seq_along(varnames)) {
varname <- varnames[[i]]
products[[varname]] <- multiplyIndicators(indicators[relationMatrix[[varname]]])
}
products
}
modsem(testModel, testData) -> spec
help(apply)
createIndicatorProducts <- function(relationMatrix, data, centered = TRUE) {
# Getting the indicatorProduct names
varnames <- colnames(relationMatrix)
# Getting all indicatornames used to create the products
allIndicatorNames <- relationMatrix |>
unlist() |>
unname() |>
unique()
print(allIndicatorNames)
# Getting a dataframe with all the indiactors and their values
indicators <- data[allIndicatorNames]
# Centering them, if center == TRUE
if (centered == TRUE) {
indicators <- apply(indicators, 2, scale, scale = FALSE, simplify = FALSE)
}
print(indicators)
# Creating a dataframe to hold the computed indicatorproducts
products <- data.frame(matrix(ncol = length(varnames), nrow = nrow(data)))
# Setting the productames (e.g., var1var2 = var1*var2)
colnames(products) <- varnames
# Loop to create the indicatorProducts
for (i in seq_along(varnames)) {
varname <- varnames[[i]]
products[[varname]] <- multiplyIndicators(indicators[relationMatrix[[varname]]])
}
products
}
modsem(testModel, testData) -> spec
createIndicatorProducts <- function(relationMatrix, data, centered = TRUE) {
# Getting the indicatorProduct names
varnames <- colnames(relationMatrix)
# Getting all indicatornames used to create the products
allIndicatorNames <- relationMatrix |>
unlist() |>
unname() |>
unique()
print(allIndicatorNames)
# Getting a dataframe with all the indiactors and their values
indicators <- data[allIndicatorNames]
# Centering them, if center == TRUE
if (centered == TRUE) {
indicators <- apply(indicators, 2, scale, scale = FALSE) |>
as.data.frame()
}
print(indicators)
# Creating a dataframe to hold the computed indicatorproducts
products <- data.frame(matrix(ncol = length(varnames), nrow = nrow(data)))
# Setting the productames (e.g., var1var2 = var1*var2)
colnames(products) <- varnames
# Loop to create the indicatorProducts
for (i in seq_along(varnames)) {
varname <- varnames[[i]]
products[[varname]] <- multiplyIndicators(indicators[relationMatrix[[varname]]])
}
products
}
modsem(testModel, testData) -> spec
createIndicatorProducts <- function(relationMatrix, data, centered = TRUE) {
# Getting the indicatorProduct names
varnames <- colnames(relationMatrix)
# Getting all indicatornames used to create the products
allIndicatorNames <- relationMatrix |>
unlist() |>
unname() |>
unique()
print(allIndicatorNames)
# Getting a dataframe with all the indiactors and their values
indicators <- data[allIndicatorNames]
# Centering them, if center == TRUE
if (centered == TRUE) {
indicators <- apply(indicators, 2, scale, scale = FALSE) |>
as.data.frame()
}
# Creating a dataframe to hold the computed indicatorproducts
products <- data.frame(matrix(ncol = length(varnames), nrow = nrow(data)))
# Setting the productames (e.g., var1var2 = var1*var2)
colnames(products) <- varnames
# Loop to create the indicatorProducts
for (i in seq_along(varnames)) {
varname <- varnames[[i]]
products[[varname]] <- multiplyIndicators(indicators[relationMatrix[[varname]]])
}
products
}
spec$productIndicators
apply(spec$productIndicators, 1, mean)
apply(spec$productIndicators, 2, mean)
apply(spec$productIndicators$XZ, 2, mean)
createIndicatorProducts <- function(relationMatrix, data, centered = TRUE) {
# Getting the indicatorProduct names
varnames <- colnames(relationMatrix)
# Getting all indicatornames used to create the products
allIndicatorNames <- relationMatrix |>
unlist() |>
unname() |>
unique()
print(allIndicatorNames)
# Getting a dataframe with all the indiactors and their values
indicators <- data[allIndicatorNames]
# Centering them, if center == TRUE
if (centered == TRUE) {
indicators <- apply(indicators, 2, scale, scale = FALSE) |>
as.data.frame()
}
print(apply(indicators, 2, mean))
# Creating a dataframe to hold the computed indicatorproducts
products <- data.frame(matrix(ncol = length(varnames), nrow = nrow(data)))
# Setting the productames (e.g., var1var2 = var1*var2)
colnames(products) <- varnames
# Loop to create the indicatorProducts
for (i in seq_along(varnames)) {
varname <- varnames[[i]]
products[[varname]] <- multiplyIndicators(indicators[relationMatrix[[varname]]])
}
products
}
modsem(testModel, testData)
modsem(testModel, testData) -> spec
createIndicatorProducts <- function(relationMatrix, data, centered = FALSE) {
# Getting the indicatorProduct names
varnames <- colnames(relationMatrix)
# Getting all indicatornames used to create the products
allIndicatorNames <- relationMatrix |>
unlist() |>
unname() |>
unique()
# Getting a dataframe with all the indiactors and their values
indicators <- data[allIndicatorNames]
# Centering them, if center == TRUE
if (centered == TRUE) {
indicators <- apply(indicators, 2, scale, scale = FALSE) |>
as.data.frame()
}
print(apply(indicators, 2, mean))
# Creating a dataframe to hold the computed indicatorproducts
products <- data.frame(matrix(ncol = length(varnames), nrow = nrow(data)))
# Setting the productames (e.g., var1var2 = var1*var2)
colnames(products) <- varnames
# Loop to create the indicatorProducts
for (i in seq_along(varnames)) {
varname <- varnames[[i]]
products[[varname]] <- multiplyIndicators(indicators[relationMatrix[[varname]]])
}
products
}
modsem(testModel, testData) -> spec
createIndicatorProducts <- function(relationMatrix, data, centered = FALSE) {
# Getting the indicatorProduct names
varnames <- colnames(relationMatrix)
# Getting all indicatornames used to create the products
allIndicatorNames <- relationMatrix |>
unlist() |>
unname() |>
unique()
# Getting a dataframe with all the indiactors and their values
indicators <- data[allIndicatorNames]
# Centering them, if center == TRUE
if (centered == TRUE) {
indicators <- apply(indicators, 2, scale, scale = FALSE) |>
as.data.frame()
}
# Creating a dataframe to hold the computed indicatorproducts
products <- data.frame(matrix(ncol = length(varnames), nrow = nrow(data)))
# Setting the productames (e.g., var1var2 = var1*var2)
colnames(products) <- varnames
# Loop to create the indicatorProducts
for (i in seq_along(varnames)) {
varname <- varnames[[i]]
products[[varname]] <- multiplyIndicators(indicators[relationMatrix[[varname]]])
}
products
}
createProductIndicators.rca <- function(modelSpecification) {
# Compute indicatorProducts (wihtout centering the variables)
indicatorProducts <- lapply(modelSpecification$relationMatrix, createIndicatorProducts, modelSpecification$data,
centered = FALSE)
}
createProductIndicators.rca <- function(modelSpecification, ...) {
# Compute indicatorProducts (wihtout centering the variables)
indicatorProducts <- lapply(modelSpecification$relationMatrix, createIndicatorProducts, modelSpecification$data,
centered = FALSE)
}
createProductIndicators.rca <- function(modelSpecification, ...) {
# Compute indicatorProducts (wihtout centering the variables)
indicatorProducts <- lapply(modelSpecification$relationMatrix, createIndicatorProducts, modelSpecification$data,
centered = FALSE)
}
createIndicatorProducts <- function(relationMatrix, data, centered = FALSE) {
# Getting the indicatorProduct names
varnames <- colnames(relationMatrix)
# Getting all indicatornames used to create the products
allIndicatorNames <- relationMatrix |>
unlist() |>
unname() |>
unique()
# Getting a dataframe with all the indiactors and their values
indicators <- data[allIndicatorNames]
# Centering them, if center == TRUE
if (centered == TRUE) {
indicators <- apply(indicators, 2, scale, scale = FALSE) |>
as.data.frame()
}
print(apply(indicators, 2, mean))
# Creating a dataframe to hold the computed indicatorproducts
products <- data.frame(matrix(ncol = length(varnames), nrow = nrow(data)))
# Setting the productames (e.g., var1var2 = var1*var2)
colnames(products) <- varnames
# Loop to create the indicatorProducts
for (i in seq_along(varnames)) {
varname <- varnames[[i]]
products[[varname]] <- multiplyIndicators(indicators[relationMatrix[[varname]]])
}
products
}
modsem(testModel, testData, centered = TRUE) -> spec
modsem(testModel, testData, centered = FALSE) -> spec
modsem <- function(modelSyntax,
data,
method = "rca",
specifyCovs = TRUE,
firstFixed = TRUE ,
...) {
# Get the specifications of the model
modelSpecification <- createModelSpecification(modelSyntax, data, method = method, ...)
modelSpecification
}
modsem(testModel, testData, centered = TRUE) -> spec
createProductIndicators.rca <- function(modelSpecification, ...) {
# Compute indicatorProducts (wihtout centering the variables)
indicatorProducts <- lapply(modelSpecification$relationMatrix, createIndicatorProducts, modelSpecification$data,
...)
}
modsem(testModel, testData, centered = TRUE) -> spec
getProductIndicators(example3)
lapply(getProductIndicators(example3), unlist)
getIndividualIndicators <- function(modelSyntax) {
# List with vectors
# Example:
indicators <- getProductIndicators(modelSyntax)
lapply(indicators, function(x) unname(unlist(x)))
}
getIndividualIndicators(example3)
createModelSpecification <- function(modelSyntax, data, method = "rca") {
modelSpecification <- list(
originalSyntax = modelSyntax,
# I might not need these two, since relationIndicatorLatentCombo contains the same info
# productCombos = createProductCombos(modelSyntax),
# indicatorProductNames = createIndicatorNames(modelSyntax),
indicatorNamesLatentProducts = getIndividualIndicators(modelSyntax),
# This is a combination of the two above:
# I definetely need a shorter word for this
relationMatrix = relationIndicatorLatentCombo(modelSyntax),
data = data
)
# setting class to method used
class(modelSpecification) <- method
# computing the productindicators based on class/method
modelSpecification$productIndicators <- createProductIndicators(modelSpecification)
# returning object
modelSpecification
}
createModelSpecification <- function(modelSyntax, data, method = "rca") {
modelSpecification <- list(
originalSyntax = modelSyntax,
# I might not need these two, since relationIndicatorLatentCombo contains the same info
# productCombos = createProductCombos(modelSyntax),
# indicatorProductNames = createIndicatorNames(modelSyntax),
indicatorNames = getIndividualIndicators(modelSyntax),
# This is a combination of the two above:
# I definetely need a shorter word for this
relationMatrix = relationIndicatorLatentCombo(modelSyntax),
data = data
)
# setting class to method used
class(modelSpecification) <- method
# computing the productindicators based on class/method
modelSpecification$productIndicators <- createProductIndicators(modelSpecification)
# returning object
modelSpecification
}
formals(createIndicatorProducts)
createIndicatorProducts <- function(relationMatrix, indicatorNames, data, centered = FALSE) {
# Getting the indicatorProduct names
varnames <- colnames(relationMatrix)
# Getting a dataframe with all the indiactors and their values
indicators <- data[indicatorNames]
# Centering them, if center == TRUE
if (centered == TRUE) {
indicators <- apply(indicators, 2, scale, scale = FALSE) |>
as.data.frame()
}
# jUST FOR TESTING
print(apply(indicators, 2, mean))
# Creating a dataframe to hold the computed indicatorproducts
products <- data.frame(matrix(ncol = length(varnames), nrow = nrow(data)))
# Setting the productames (e.g., var1var2 = var1*var2)
colnames(products) <- varnames
# Loop to create the indicatorProducts
for (i in seq_along(varnames)) {
varname <- varnames[[i]]
products[[varname]] <- multiplyIndicators(indicators[relationMatrix[[varname]]])
}
products
}
formals(createIndicatorProducts)
createProductIndicators.rca <- function(modelSpecification, ...) {
# Compute indicatorProducts (wihtout centering the variables)
indicatorProducts <- lapply(relationMatrix, createIndicatorProducts,
indicatorNames = modelSpecification$indicatorNames,
data = modelSpecification$data,
centered = FALSE)
}
modsem(testModel, testData, centered = TRUE) -> spec
modsem(testModel, testData) -> spec
createProductIndicators.rca <- function(modelSpecification, ...) {
# Compute indicatorProducts (wihtout centering the variables)
indicatorProducts <- lapply(modelSpecification$relationMatrix, createIndicatorProducts,
indicatorNames = modelSpecification$indicatorNames,
data = modelSpecification$data,
centered = FALSE)
}
modsem(testModel, testData) -> spec
createIndicatorProducts <- function(modelSpecification, centered = FALSE) {
relationMatrix <- modelSpecification$relationMatrix
indicatorNames <- modelSpecification$indicatorNames
data <- modelSpecification$data
# Getting the indicatorProduct names
varnames <- colnames(relationMatrix)
# Getting a dataframe with all the indiactors and their values
indicators <- data[indicatorNames]
# Centering them, if center == TRUE
if (centered == TRUE) {
indicators <- apply(indicators, 2, scale, scale = FALSE) |>
as.data.frame()
}
# jUST FOR TESTING
print(apply(indicators, 2, mean))
# Creating a dataframe to hold the computed indicatorproducts
products <- data.frame(matrix(ncol = length(varnames), nrow = nrow(data)))
# Setting the productames (e.g., var1var2 = var1*var2)
colnames(products) <- varnames
# Loop to create the indicatorProducts
for (i in seq_along(varnames)) {
varname <- varnames[[i]]
products[[varname]] <- multiplyIndicators(indicators[relationMatrix[[varname]]])
}
products
}
modsem(testModel, testData) -> spec
createIndicatorProducts <- function(modelSpecification, centered = FALSE) {
relationMatrix <- modelSpecification$relationMatrix
indicatorNames <- modelSpecification$indicatorNames
data <- modelSpecification$data
# Getting the indicatorProduct names
varnames <- colnames(relationMatrix)
# Getting a dataframe with all the indiactors and their values
indicators <- data[indicatorNames]
# Centering them, if center == TRUE
if (centered == TRUE) {
indicators <- apply(indicators, 2, scale, scale = FALSE) |>
as.data.frame()
}
# jUST FOR TESTING
print(apply(indicators, 2, mean))
# Creating a dataframe to hold the computed indicatorproducts
products <- data.frame(matrix(ncol = length(varnames), nrow = nrow(data)))
# Setting the productames (e.g., var1var2 = var1*var2)
colnames(products) <- varnames
# Loop to create the indicatorProducts
for (i in seq_along(varnames)) {
varname <- varnames[[i]]
products[[varname]] <- multiplyIndicators(indicators[relationMatrix[[varname]]])
}
products
}
createProductIndicators.rca <- function(modelSpecification, ...) {
# Compute indicatorProducts (wihtout centering the variables)
indicatorProducts <- lapply(modelSpecification, createIndicatorProducts, centered = FALSE)
}
modsem(testModel, testData) -> spec
source("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/modsem/R/buildModelSpecification.R", echo=TRUE)
source("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/modsem/R/rca.R", echo=TRUE)
modsem(testModel, testData) -> spec
