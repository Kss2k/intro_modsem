lavaanEstimation <- lavaan::sem(newSyntax, newData)
# Adding a bunch of stuff to the model, befur i return it
modelSpecification$productIndicators <- productIndicators
modelSpecification$newSyntax <- newSyntax
modelSpecification$newData <- newData
modelSpecification$lavaan <- lavaanEstimation
# this is not pretty either
class(modelSpecification) <- "modsem"
modelSpecification
}
m4 <- modsem(regModelModsem, df1, method = "unconstrained",  isMeasurementSpecified = TRUE)
latentModelRca <- modsem(m1, df1, method = "rca")
m1 <- '
# Outer Model
X =~ x1 + x2 +x3
Y =~ y1 + y2 + y3
Z =~ z1 + z2 + z3
# Inner model
Y ~ X + Z + X:Z
'
realModel <- lm(realY ~ realX*realZ, df1)
library(lavaan)
library(modsem)
setwd("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/data")
df1 <- readRDS("exampleData1.rds")
df2 <- readRDS("exampleData4.rds")
df3 <- readRDS("exampleData3.rds")
regModel <- '
y1 ~ x1 + z1 + x1z1
'
df1Mod <- df1
df1Mod$x1z1 <- df1$x1*df1$z1
sem(regModel, df1Mod) -> simple
summary(simple)
regModelModsem <- '
y1 ~ x1 + z1 + x1:z1
'
m4 <- modsem(regModelModsem, df1, method = "unconstrained",  isMeasurementSpecified = TRUE)
parseLavaan(regModelModsem)
View(m4)
m4[["productIndicators"]][["x1z1"]]
m4[["productIndicators"]][["x1z1"]][1:5,]
scale(df1$x1, scale = FALSE) * scale(df1$z1, scale = FALSE)
m4[["productIndicators"]][["x1z1"]][1:5,]
m4[["productIndicators"]][["x1z1"]][1:5,][1:5]
scale(df1$x1, scale = FALSE) * scale(df1$z1, scale = FALSE)
m4[["productIndicators"]][["x1z1"]][1:5,][1:5]
(scale(df1$x1, scale = FALSE) * scale(df1$z1, scale = FALSE))[1:5]
df1Mod$scaled_x1z2 <- scale(df1$x1, scale = FALSE) * scale(df1$z1, scale = FALSE)
o
regModel <- '
y1 ~ x1 + z1 + scaled_x1z1
'
df1Mod <- df1
df1Mod$x1z1 <- df1$x1*df1$z1
df1Mod$scaled_x1z2 <- scale(df1$x1, scale = FALSE) * scale(df1$z1, scale = FALSE)
sem(regModel, df1Mod) -> simple
regModel <- '
y1 ~ x1 + z1 + scaled_x1z1
'
df1Mod <- df1
df1Mod$x1z1 <- df1$x1*df1$z1
df1Mod$scaled_x1z1 <- scale(df1$x1, scale = FALSE) * scale(df1$z1, scale = FALSE)
sem(regModel, df1Mod) -> simple
summary(simple)
regModel <- '
y1 ~ x1 + z1 + scaled_x1z1
'
df1Mod <- df1
df1Mod$x1z1 <- df1$x1*df1$z1
df1Mod$scaled_x1z1 <- scale(df1$x1, scale = FALSE) * scale(df1$z1, scale = FALSE)
sem(regModel, df1Mod) -> simple
summary(simple)
regModelModsem <- '
y1 ~ x1 + z1 + x1:z1
'
parseLavaan(regModelModsem)
m4 <- modsem(regModelModsem, df1, method = "unconstrained",  isMeasurementSpecified = TRUE)
View(m4)
m4$newData
regModel <- '
y1 ~ x1 + z1 + scaled_x1z1
'
df1Mod <- df1
#df1Mod$x1z1 <- df1$x1*df1$z1
df1Mod$x1z1 <- scale(df1$x1, scale = FALSE) * scale(df1$z1, scale = FALSE)
sem(regModel, df1Mod) -> simple
regModel <- '
y1 ~ x1 + z1 + x1z1
'
df1Mod <- df1
#df1Mod$x1z1 <- df1$x1*df1$z1
df1Mod$x1z1 <- scale(df1$x1, scale = FALSE) * scale(df1$z1, scale = FALSE)
sem(regModel, df1Mod) -> simple
summary(simple)
regModelModsem <- '
y1 ~ x1 + z1 + x1:z1
'
parseLavaan(regModelModsem)
m4 <- modsem(regModelModsem, df1, method = "unconstrained",  isMeasurementSpecified = TRUE)
head(m4$newData)
View(m4)
regModelModsem <- '
y1 ~ x1 + z1 + x1:z1
'
parseLavaan(regModelModsem)
m4 <- modsem(regModelModsem, df1, method = "unconstrained",  isMeasurementSpecified = TRUE)
summary(m4)
head(m4$newData)
View(m4)
summary.modsem(m4)
summary.modsem <- function(object) {
lavaan::summary(object$lavaan)
}
summary(m4)
summary.modsem <- function(object, ...) {
lavaan::summary(object$lavaan)
}
summary(m4)
summary.modsem <- function(object, ...) {
lavaan::summary(object$lavaan)
}
modsem <- function(modelSyntax,
data,
method = "rca",
isMeasurementSpecified = FALSE,
...) {
# Get the specifications of the model
modelSpecification <-
parseLavaan(modelSyntax,isMeasurementSpecified = isMeasurementSpecified)
# Setting parameters according to method
if (method = NULL) {
modsem <- function(modelSyntax,
data,
method = "rca",
isMeasurementSpecified = FALSE,
...) {
# Get the specifications of the model
modelSpecification <-
parseLavaan(modelSyntax,isMeasurementSpecified = isMeasurementSpecified)
# Setting parameters according to method
if (method == NULL) {
warning2("No method was chosen, using specifications set indside the function call")
}
# Calculating productinidicators based on method
productIndicators <- createProductIndicators(modelSpecification)
# Merging productIndicators into a single dataset (NB i should add a
# warning if they contain the same names), and delete copies...
mergedProductIndicators <- purrr::list_cbind(unname(productIndicators))
# Genereating a new syntax with constraints and measurmentmodel for latent
# products
newSyntax <- generateSyntax(modelSpecification,
isMeasurementSpecified = isMeasurementSpecified)
# Creating a new dataset with the productindicators
newData <- cbind.data.frame(data, mergedProductIndicators)
# Estimating the model via lavaan::sem()
lavaanEstimation <- lavaan::sem(newSyntax, newData)
# Adding a bunch of stuff to the model, befur i return it
modelSpecification$productIndicators <- productIndicators
modelSpecification$newSyntax <- newSyntax
modelSpecification$newData <- newData
modelSpecification$lavaan <- lavaanEstimation
# this is not pretty either
class(modelSpecification) <- "modsem"
modelSpecification
}
modsem(NULL)
modsem(regModel, method = NULL)
modsem <- function(modelSyntax,
data,
method = "rca",
isMeasurementSpecified = FALSE,
...) {
# Get the specifications of the model
modelSpecification <-
parseLavaan(modelSyntax,isMeasurementSpecified = isMeasurementSpecified)
# Setting parameters according to method
if (is.null(method)) {
warning2("No method was chosen, using specifications set indside the function call")
}
# Calculating productinidicators based on method
productIndicators <- createProductIndicators(modelSpecification)
# Merging productIndicators into a single dataset (NB i should add a
# warning if they contain the same names), and delete copies...
mergedProductIndicators <- purrr::list_cbind(unname(productIndicators))
# Genereating a new syntax with constraints and measurmentmodel for latent
# products
newSyntax <- generateSyntax(modelSpecification,
isMeasurementSpecified = isMeasurementSpecified)
# Creating a new dataset with the productindicators
newData <- cbind.data.frame(data, mergedProductIndicators)
# Estimating the model via lavaan::sem()
lavaanEstimation <- lavaan::sem(newSyntax, newData)
# Adding a bunch of stuff to the model, befur i return it
modelSpecification$productIndicators <- productIndicators
modelSpecification$newSyntax <- newSyntax
modelSpecification$newData <- newData
modelSpecification$lavaan <- lavaanEstimation
# this is not pretty either
class(modelSpecification) <- "modsem"
modelSpecification
}
modsem(regModel, method = NULL)
is.numeric(as.factor(1))
is.integer(as.factor(1))
is.integer(as.factor(1, levels = c(1, 2)))
is.integer(as.factor(1, level = c(1, 2)))
as.factor(1:10)
is.numeric(as.factor(1:10))
as.numeric(as.factor(1:10))
# scale numeric vector is numeric
scaleIfNumeric <- function(x, scaleFactor = TRUE) {
if (is.null(x)) {
warning2("x in scaleIfNumeric was NULL")
return(NULL)
}
if (scaleFactor == TRUE & is.factor(x)) {
x <- as.numeric(x)
}
if (is.numeric(x)) {
as.numeric(x)
} else x
}
scaleIfNumeric(as.factor(1:10))
# scale numeric vector is numeric
scaleIfNumeric <- function(x, scaleFactor = TRUE) {
if (is.null(x)) {
warning2("x in scaleIfNumeric was NULL")
return(NULL)
}
if (scaleFactor == TRUE & is.factor(x)) {
x <- as.numeric(x)
}
if (is.numeric(x)) {
scale(x)
} else x
}
scaleIfNumeric(as.factor(1:10))
scaleIfNumeric(as.factor(1:10), FALSE)
scaleIfNumeric(as.character(1:10), FALSE)
# scale numeric vector is numeric
scaleIfNumeric <- function(x, scaleFactor = TRUE) {
if (is.null(x)) {
warning2("x in scaleIfNumeric was NULL")
return(NULL)
}
if (scaleFactor == TRUE & is.factor(x)) {
x <- as.numeric(x)
}
if (is.numeric(x)) {
scale(x)
} else x
}
lapplyDf(iris, scaleIfNumeric)
str(iris)
lapplyDf(iris, scaleIfNumeric, FALSE)
createProductIndicators <- function(modelSpecification,
data,
centeredProducts = FALSE,
residualsProducts = FALSE) {
indicatorProducts <- purrr::map2(.x = modelSpecification$relationalDfs,
.y = modelSpecification$indicatorsInProductTerms,
.f = createIndicatorProducts,
data = modelSpecification$data,
centered = centeredProducts)
if (residualsProducts == TRUE) {
purrr::map2(.x = indicatorProducts,
.y = modelSpecification$indicatorsInProductTerms,
.f = calculateResidualsDf,
data = modelSpecification$data)
} else if (residualsProducts == FALSE) {
indicatorProducts
} else {
stop2("residualProducts was neither FALSE nor TRUE in createProductIndicators")
}
}
modsem2.1 <- function(modelSyntax = NULL,
data = NULL,
method = "rca",
standardizeData = FALSE,
isMeasurementSpecified = FALSE,
centeredProducts = FALSE,
residualsProducts = FALSE,
residualCovSyntax = FALSE,
constrainedProductMean = FALSE,
...) {
if (is.null(modelSyntax)) {
stop2("No model syntax provided in modsem")
}
if (is.null(data)) {
stop2("No data provided in modsem")
}
# Setting parameters according to method
if (is.null(method)) {
warning2("Method was NULL, using specifications set indside the function call")
} else if (method == "rca") {
centeredProducts <- FALSE
residualsProducts <- TRUE
residualCovSyntax <- TRUE
constrainedProductMean <- FALSE
} else if (method = "unconstrained") {
generateSyntax <- function(modelSpecification,
isMeasurementSpecified = FALSE,
residualCovSyntax = FALSE,
constrainedProductMean = FALSE) {
modelSyntax <- modelSpecification$lavaanSyntax
relationalDfs <- modelSpecification$relationalDfs
productNames <- names(relationalDfs)
addedSyntax <- c()
# Measurement model latent products ------------------------------------------
if (!is.logical(residualCovSyntax)) {
stop2("residualCovSyntax is not FALSE or TRUE in generateSyntax")
} else if (isMeasurementSpecified == FALSE) {
measurementSyntax <-
purrr::map2_chr(.x = modelSpecification$productNamesLatents,
.y = modelSpecification$indicatorProductNamesLatents,
.f = generateFormula.measurement,
operator = "=~",
firstFixed = TRUE)
addedSyntax <- c(measurementSyntax, addedSyntax)
}
# Residual covariances -------------------------------------------------------
if (!is.logical(residualCovSyntax)) {
stop2("residualCovSyntax is not FALSE or TRUE in generateSyntax")
} else if (residualCovSyntax == TRUE) {
residualCovariances <- purrr::map2(.x = relationalDfs,
.y = productNames,
.f = getSyntaxResidualCovariances) |>
unlist()
addedSyntax <- c(addedSyntax, residualCovariances)
}
# Constrained product mean syntax --------------------------------------------
if (constrainedProductMean == TRUE) {
meanSyntax <-
generateRestrictedMeanSyntax(modelSpecification$productNames,
modelSpecification$elementsInProductNames)
addedSyntax <- c(addedSyntax, meanSyntax)
}
syntaxElements <- c(modelSyntax, addedSyntax)
stringr::str_c(syntaxElements, collapse = "\n")
}
modsem2.1 <- function(modelSyntax = NULL,
data = NULL,
method = "rca",
standardizeData = FALSE,
isMeasurementSpecified = FALSE,
centeredProducts = FALSE,
residualsProducts = FALSE,
residualCovSyntax = FALSE,
constrainedProductMean = FALSE,
...) {
if (is.null(modelSyntax)) {
stop2("No model syntax provided in modsem")
}
if (is.null(data)) {
stop2("No data provided in modsem")
}
# Setting parameters according to method -------------------------------------
if (is.null(method)) {
warning2("Method was NULL, using specifications set indside the function call")
} else if (method == "rca") {
centeredProducts <- FALSE
residualsProducts <- TRUE
residualCovSyntax <- TRUE
constrainedProductMean <- FALSE
} else if (method = "unconstrained") {
source("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/modsem/R/modsem2.1.R", echo=TRUE)
source("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/modsem/R/modsem2.1.R", echo=TRUE)
source("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/modsem/R/utils.R", echo=TRUE)
source("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/modsem/R/parseLavaan2.1.R", echo=TRUE)
library(lavaan)
library(modsem)
setwd("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/data")
df1 <- readRDS("exampleData1.rds")
df2 <- readRDS("exampleData4.rds")
df3 <- readRDS("exampleData3.rds")
m1 <- '
# Outer Model
X =~ x1 + x2 +x3
Y =~ y1 + y2 + y3
Z =~ z1 + z2 + z3
# Inner model
Y ~ X + Z + X:Z
'
realModel <- lm(realY ~ realX*realZ, df1)
summary(realModel)
latentModelRca <- modsem2.1(m1, df1, method = "rca")
latentModelRca <- modsem(m1, df1, method = "rca")
library(lavaan)
#library(modsem)
setwd("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/data")
df1 <- readRDS("exampleData1.rds")
df2 <- readRDS("exampleData4.rds")
df3 <- readRDS("exampleData3.rds")
source("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/modsem/R/modsem2.1.R", echo=TRUE)
source("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/modsem/R/utils.R", echo=TRUE)
source("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/modsem/R/parseLavaan2.1.R", echo=TRUE)
m1 <- '
# Outer Model
X =~ x1 + x2 +x3
Y =~ y1 + y2 + y3
Z =~ z1 + z2 + z3
# Inner model
Y ~ X + Z + X:Z
'
realModel <- lm(realY ~ realX*realZ, df1)
summary(realModel)
latentModelRca <- modsem(m1, df1, method = "rca")
source("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/modsem/R/modsem2.1.R", echo=TRUE)
latentModelRca <- modsem(m1, df1, method = "rca")
createProductIndicators <- function(modelSpecification,
data,
centeredProducts = FALSE,
residualsProducts = FALSE) {
indicatorProducts <- purrr::map2(.x = modelSpecification$relationalDfs,
.y = modelSpecification$indicatorsInProductTerms,
.f = createIndicatorProducts,
data = data,
centered = centeredProducts)
if (residualsProducts == TRUE) {
purrr::map2(.x = indicatorProducts,
.y = modelSpecification$indicatorsInProductTerms,
.f = calculateResidualsDf,
data = modelSpecification$data)
} else if (residualsProducts == FALSE) {
indicatorProducts
} else {
stop2("residualProducts was neither FALSE nor TRUE in createProductIndicators")
}
}
source("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/modsem/R/modsem2.1.R", echo=TRUE)
latentModelRca <- modsem(m1, df1, method = "rca")
source("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/modsem/R/modsem2.1.R", echo=TRUE)
latentModelRca <- modsem(m1, df1, method = "rca")
source("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/modsem/R/modsem2.1.R", echo=TRUE)
latentModelRca <- modsem(m1, df1, method = "rca")
source("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/modsem/R/modsem2.1.R", echo=TRUE)
latentModelRca <- modsem(m1, df1, method = "rca")
latentModelRca <- modsem(m1, df1, method = "rca")
source("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/modsem/R/modsem2.1.R", echo=TRUE)
latentModelRca <- modsem2.1(m1, df1, method = "rca")
latentModelRca <- modsem2.1(m1, df1, method = "rca")
lavaan::summary(latentModelRca$lavaan)
summary.modsem(latentModelRca)
source("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/modsem/R/modsem2.1.R", echo=TRUE)
latentModelRca <- modsem2.1(m1, df1, method = "rca")
lavaan::summary(latentModelRca$lavaan)
summary.modsem(latentModelRca)
source("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/modsem/R/modsem2.1.R", echo=TRUE)
library(modsem)
library(lavaan)
#library(modsem)
setwd("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/data")
df1 <- readRDS("exampleData1.rds")
df2 <- readRDS("exampleData4.rds")
df3 <- readRDS("exampleData3.rds")
m1 <- '
# Outer Model
X =~ x1 + x2 +x3
Y =~ y1 + y2 + y3
Z =~ z1 + z2 + z3
# Inner model
Y ~ X + Z + X:Z
'
realModel <- lm(realY ~ realX*realZ, df1)
summary(realModel)
latentModelRca <- modsem2.1(m1, df1, method = "rca")
latentModelRca <- modsem(m1, df1, method = "rca")
lavaan::summary(latentModelRca$lavaan)
modsem(latentModelRca)
summary(latentModelRca)
summary.modsem(latentModelRca)
library(modsem)
library(lavaan)
#library(modsem)
setwd("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/data")
df1 <- readRDS("exampleData1.rds")
df2 <- readRDS("exampleData4.rds")
df3 <- readRDS("exampleData3.rds")
latentModelRca <- modsem(m1, df1, method = "rca")
lavaan::summary(latentModelRca$lavaan)
summary.modsem(latentModelRca)
summary.modsem(latentModelRca)
summary.modsem(latentModelRca)
summary(latentModelRca)
class(latentModelRca)
summary.modsem(latentModelRca)
View(summary)
regModel <- '
y1 ~ x1 + z1 + x1z1
'
df1Mod <- df1
#df1Mod$x1z1 <- df1$x1*df1$z1
df1Mod$x1z1 <- scale(df1$x1, scale = FALSE) * scale(df1$z1, scale = FALSE)
sem(regModel, df1Mod) -> simple
summary(simple)
regModel <- '
y1 ~ x1 + z1 + x1z1
'
df1Mod <- df1
df1Mod$x1z1 <- df1$x1*df1$z1
#df1Mod$x1z1 <- scale(df1$x1, scale = FALSE) * scale(df1$z1, scale = FALSE)
sem(regModel, df1Mod) -> simple
summary(simple)
regModelModsem <- '
y1 ~ x1 + z1 + x1:z1
'
parseLavaan(regModelModsem)
m4 <- modsem(regModelModsem, df1, method = "regression",  isMeasurementSpecified = TRUE)
summary.modsem(m4)
m4 <- modsem(regModelModsem, df1, method = "regression",  isMeasurementSpecified = TRUE)
summary.modsem(m4)
