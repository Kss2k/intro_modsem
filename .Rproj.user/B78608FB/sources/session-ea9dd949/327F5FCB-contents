# Creating the data
addRandomVariance <- function(x, proportion) {
  x + rnorm(length(x), 0, sd(x))*proportion
}

# TEst data1

# Latent Variable X
X <- runif(1000, 1, 10)
x1 <- addRandomVariance(X, 0.7)
x2 <- addRandomVariance(X, 0.8)
x3 <- addRandomVariance(X, 0.4)

# Latent Variable Z
Z <- runif(1000, 1, 10)
z1 <- addRandomVariance(Z, 0.4)
z2 <- addRandomVariance(Z, 0.6)
z3 <- addRandomVariance(Z, 0.5)

# Latent Variable Y = X + Z + X:Z

YnoError <- 0.3*X + 0.4*Z + 0.2*Z*X
#scaledY <- scale(YnoError)*10 + 5
Y <- addRandomVariance(YnoError, 0.7)
y1 <- addRandomVariance(Y, 0.5)
y2 <- addRandomVariance(Y, 0.6)
y3 <- addRandomVariance(Y, 0.4)

testData <- data.frame(realY = Y,
                       realX = X,
                       realZ = Z,
                       x1 = x1,
                       x2 = x2,
                       x3 = x3,
                       y1 = y1,
                       y2 = y2,
                       y3 = y3,
                       z1 = z1,
                       z2 = z2,
                       z3 = z3)


manualSyntax <- '
# Structural Model
  X =~ x1 + x2
  Y =~ y1 + y2
  Z =~ z1 + z2

  # Inner model
  Y ~ X + Z + XZ

  # ModSEM: Structural Model
  XZ =~ res_x1z1 + res_x2z1 + res_x1z2 + res_x2z2


  # ModSEM: Residual (Co)Variances
  res_x2z1 ~~ res_x1z1
  res_x1z2 ~~ res_x1z1
  res_x2z2 ~~ 0*res_x1z1
  res_x1z2 ~~ 0*res_x2z1
  res_x2z2 ~~ res_x2z1
  res_x2z2 ~~ res_x1z2
'

manualModel <- lavaan::sem(manualSyntax, manualData)
summary(manualModel)



#### Model 1 ####

testManualModel <- '
  # Outer Model
  X =~ x1 + x2 +x3
  Y =~ y1 + y2 + y3
  Z =~ z1 + z2 + z3

  # Inner model
  Y ~ X + Z + X:Z

  # Covariances
  x1 ~~ x2
  x1 ~~ 0*x3
  z1 ~~ z2
'


realModel <- lm(Y ~ realX*realZ, testData)
#latentModel <- modsem(testModel, testData)
#lavaan::summary(latentModel$lavaan)


#### Model 2: small version of model 1 ####

# Manual calculation
manualData <- testData
manualData$x1z1 <- manualData$x1*manualData$z1
manualData$x1z2 <- manualData$x1*manualData$z2
manualData$x2z1 <- manualData$x2*manualData$z1
manualData$x2z2 <- manualData$x2*manualData$z2


manualData$res_x1z1 <- lm(x1z1 ~ x1+ z1+ x2 + z2, data = manualData)$residuals
manualData$res_x1z2 <- lm(x1z2 ~ x1+ z1+ x2 + z2, data = manualData)$residuals
manualData$res_x2z1 <- lm(x2z1 ~ x1+ z1+ x2 + z2, data = manualData)$residuals
manualData$res_x2z2 <- lm(x2z2 ~ x1+ z1+ x2 + z2, data = manualData)$residuals


manualSyntax <- '
# Structural Model
  X =~ x1 + x2
  Y =~ y1 + y2
  Z =~ z1 + z2

  # Inner model
  Y ~ X + Z + XZ

  # ModSEM: Structural Model
  XZ =~ res_x1z1 + res_x2z1 + res_x1z2 + res_x2z2
  X ~~ CovXZ*Z
  XZ ~ CovXZ*1
  # ModSEM: Residual (Co)Variances
  res_x2z1 ~~ res_x1z1
  res_x1z2 ~~ res_x1z1
  res_x2z2 ~~ 0*res_x1z1
  res_x1z2 ~~ 0*res_x2z1
  res_x2z2 ~~ res_x2z1
  res_x2z2 ~~ res_x1z2
'

manualModel <- lavaan::sem(manualSyntax, manualData)
summary(manualModel)


#### Model 3 #####

testObservedSpecified <- '
  # Outer Model
  X =~ x1 + x2
  Y =~ y1 + y2
  Z =~ z1 + z2
  Z:x1 =~ z1:x1 + z2:x1
  X:Z =~ x1:z1 + x1:z2
  # Inner model
  Y ~ X + Z + X:Z + x1:z1 + Z:x1 + x2:z2
'

manualData <- testData
manualData$x1z1 <- manualData$x1*manualData$z1
manualData$x1z2 <- manualData$x1*manualData$z2
manualData$x2z1 <- manualData$x2*manualData$z1
manualData$x2z2 <- manualData$x2*manualData$z2


manualData$res_x1z1 <- lm(x1z1 ~ x1+ z1#+ x2 + z2
                          , data = manualData)$residuals
manualData$res_x1z2 <- lm(x1z2 ~ x1+ z1+ x2 + z2, data = manualData)$residuals
manualData$res_x2z1 <- lm(x2z1 ~ x1+ z1+ x2 + z2, data = manualData)$residuals
manualData$res_x2z2 <- lm(x2z2 ~ x1+ z1+ x2 + z2, data = manualData)$residuals


#### Using modsem ####

testModel1 <- '
  # Outer Model
  X =~ x1 + x2
  Y =~ y1 + y2
  Z =~ z1 + z2

  # Inner model
  Y ~ X + Z + X:Z
'

testObserved <- '
  # Outer Model
  X =~ x1 + x2
  Y =~ y1 + y2
  Z =~ z1 + z2

  # Inner model
  Y ~ X + Z + X:Z + x1:z1 + Z:x1
'
testObservedSpecified <- '
  # Outer Model
  X =~ x1 + x2
  Y =~ y1 + y2
  Z =~ z1 + z2
  Z:x1 =~ z1:x1 + z2:x1
  X:Z =~ x1:z1 + x1:z2
  # Inner model
  Y ~ X + Z + X:Z + x1:z1 + Z:x1 + x2:z2
'

testModel3 <- '
  # Outer Model
  X =~ x1 + x2
  Y =~ y1 + y2
  Z =~ z1 + z2
  X:Z =~ z1:x1 + z1:x2 #+ z2:x1 + z3:x2
  # Inner model
  Y ~ X + Z + X:Z
'

mBlockModel <- '
  # Outer Model
  X =~ x1 + x2
  Y =~ y1 + y2
  Z =~ z1 + z2
  X:Z =~ z1:x1 + z1:x2 #+ z2:x1 + z3:x2
  # Inner model
  X ~ Z
  Y ~ X
'

testModel4 <- '
  # Outer Model
  X =~ x1 + x2
  Y =~ y1 + y2
  Z =~ z1 + z2
  G =~ g1 + g2
  X:Z =~ z1:x1 + z1:x2 + z2:x1 + z3:x2
  G:Z =~ g1:z1 + g2:z2
  # Inner model
  Y ~ X + Z + X:Z + G:Z
'

