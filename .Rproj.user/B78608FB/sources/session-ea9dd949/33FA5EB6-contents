

# Extract seperate expressions
seperateExpressions <- function(modelSyntax) {
  # Splitting the syntax into seperate lines
  allLines <- stringr::str_split_1(modelSyntax, "\n")

  # Removing Whitespace:
    # This might not be the best approach, but it is probably the easiest, and is safe in most instances
  whiteSpaceRemoved <- sapply(allLines, stringr::str_remove_all, " ") |>
    unlist() |>
    unname()

  # Removing empty lines
  emptyLinesRemoved <- whiteSpaceRemoved[whiteSpaceRemoved != ""]

  # Removing comments
  commentsRemoved <- emptyLinesRemoved[!grepl("^#", emptyLinesRemoved)]

  # Removing element-names
  unname(commentsRemoved)
}




# Extract interation expressions from seperate vector of expressions
# from running seperateExpressions first.
findInteractionExpressions <- function(expressions) {
  interactions <- expressions[grepl(":", expressions)]
  if (is.null(interactions)) return(errorCondition("No interactions detected"))
}




# Extract interaction expression from model syntax
getInteractions <- function(modelSyntax) {
  extractedExpressions <- seperateExpressions(modelSyntax)
  findInteractionExpressions(extractedExpressions)

}




# Function for extracting interaction tokens, without the operators
getInteractionTokens <- function(interactionExpression) {
  # This function assumes that there are no whitespaces
    # Examples:
      # extractTokens("Behaviour ~ Intention + PBC + 1*Intention:PBC + T:G")
      # extractTokens("Behaviour ~ Intention + PBC + 1*Intention:PBC")

  # Extract names to left and right of = in interaction expression
  rightAndLeft <- stringr::str_split(interactionExpression, "~") |>
    unlist()
  # Names to the right of =
  namesRight <- rightAndLeft[[2]]

  # Seperate the predictors into a vector
  predictors <- stringr::str_split(namesRight, "\\+|[:alnum:]+\\*|[:blank:]") |>
    unlist()

  # Select Interactionterms
  interactionTerms <- predictors[grepl(":", predictors)]

  # Seperate the interactonTerms, in a list
  latentProducts <- sapply(interactionTerms, stringr::str_split, ":")
  fixNames(latentProducts)

}




# function for  fixing names in extractTokens
fixNames <- function(x) {
  names(x) <- stringr::str_replace_all(names(x), ":|[:blank:]", "")
  x
}




# Extract outer (measurement) model expressions from seperate vector of expressions
# from running seperateExpressions first
findOuterExpressions <- function(expressions) {
  expressions[grepl("=~", expressions)]
}




# Get outer expressions from model syntax
getOuterExpressions <- function(modelSyntax) {
  extractedExpressions <- seperateExpressions(modelSyntax)
  findOuterExpressions(extractedExpressions)
}




# find structural expression corresponding to a single latent variable name
findSingleOuterExpression <- function(latentVariable, outerExpressions) {
  # example:
    # findSingleOuterExpression("TestY", seperateExpressions(example1) |> findOuterExpressions())
  pattern <- paste0("^", latentVariable)
  outerExpressions[grepl(pattern, outerExpressions)]

  # i should add a warning here, if there are multiple structural specifications for a single latent variable
}




# get a single structural expression from latent variable name, and model syntax
getSingleOuterExpression <- function(latentVariable, modelSyntax) {
  # example:
    #getSingleOuterExpression("TestX", example1)
  expressions <- getOuterExpressions(modelSyntax)

  findSingleOuterExpression(latentVariable, expressions)
}




# get a vector of indicators from a single latent variable name, and model syntax.
getIndicatorsSingle <- function(latentVariable, modelSyntax) {
  # Example
    # getIndicatorsSingle("PBC", example1)
  structuralExpression <- getSingleOuterExpression(latentVariable, modelSyntax)
  # Extract names to left and right of =~ in interaction expression
  rightAndLeft <- stringr::str_split(structuralExpression, "=~") |>
    unlist()
  # Names to the left of =~
  expressionIndicators <- rightAndLeft[[2]]

  # Remove +, this may not be general enough
  indicators <- stringr::str_split(expressionIndicators, "\\+|[:alnum:]+\\*|[:blank:]")
  indicators
}



# Vectorized version of getIndicatorsSingle
  # example:
# Example
# getIndicators(c("PBC", "Intention"), example1)
getIndicators <- Vectorize(getIndicatorsSingle)




# get the names of latent variables which belong to respective interaction terms
getLatentProducts <- function(modelSyntax) {
  # example
    #getLatentProducts(example1)
  interactionExpressions <- paste(getInteractions(modelSyntax), sep = ",")

  # get names in products
  LatentProducts <- getInteractionTokens(interactionExpressions)
  LatentProducts
}




getProductIndicators <- function(modelSyntax) {
  # Example:
    # getProductIndicators(example2)
  latentVariables <- getLatentProducts(modelSyntax)
  listIndicators <- lapply(latentVariables, getIndicators, modelSyntax)
  listIndicators

}


allIndicatorNames <- function(modelSyntax) {
  indicators <- getProductIndicators(modelSyntax)

  lapply(indicators, unlist) |>
    lapply(unname)
}
