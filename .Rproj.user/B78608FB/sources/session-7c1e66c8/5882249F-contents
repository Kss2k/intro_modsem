


#' Parse lavaan model
#'
#' @param modelSyntax lavaan syntax
#' @param isMeasurementSpecified have you specified the measurement model for the latent product
#'
#' @return
#' @export
#'
#' @examples
parseLavaan <- function(
    modelSyntax   = NULL,
    isMeasurementSpecified = FALSE) {

  # Checking prerequisites -----------------------------------------------------
    # Check if a modelSyntax is provided, if not we should return an error
  if (is.null(modelSyntax)) {
    stop2("No modelSyntax provided")

    # Check if .model is string
  } else if (!is.character(modelSyntax)) {
    stop2("The provided model syntax is not a string!")
  }

  # Convert to lavaan partable -------------------------------------------------
  replacementPattern <- "__COLON__"

  originalSyntax <- modelSyntax
  modelSyntax <- stringr::str_replace_all(modelSyntax, ":", replacementPattern)
  cleanedModelSyntax <- stringr::str_remove_all(modelSyntax, replacementPattern)
  # so I dont have to parse the syntax my self
  parTable <- lavaan::lavaanify(model = modelSyntax, fixed.x = FALSE)

  # Extracting some general information ----------------------------------------
    # Structural
  structuralExpressions <- parTable[parTable$op == "~",]

    # Interactions/Product expressions
  interactionExpressions <-
    parTable[grepl(replacementPattern, parTable$rhs) & parTable$op == "~", ]
  productNames <- unique(interactionExpressions$rhs)
        # Get names for productTerms without __COLON__
  productNamesCleaned <- stringr::str_remove_all(productNames,
                                                 replacementPattern)
    # Measurement
  measurementExpressions <- parTable[parTable$op %in% c("=~", "<~"), ]

  if (isMeasurementSpecified == FALSE) {
    # I should Remove already specified measurementExpressions

    # Logical vector indicating whether a row is a measurementExpression
    isMeasurement <- parTable$op %in% c("=~", "<~")

    # Logical vector indicating whether a row is a interaction
    isProductExpression <- parTable$lhs %in% productNamesCleaned

    # We want to remove latent measurement expressions
    parTable <- parTable[!(isMeasurement & isProductExpression),]

    # We should also go through our previous measurement
    # expression and remove latentExpressions
    measurementExpressions <- measurementExpressions[
      !(measurementExpressions$lhs %in% productNamesCleaned),
    ]
  }
  # Get all the indicators in the model
  indicators <- unique(measurementExpressions$rhs)
  # Get latent variable names (assumes first order)
  latentVariables <- unique(measurementExpressions$lhs)

  # Structuring the information ------------------------------------------------
    # Are products latent?
  elementsInProducts <- lapplyNamed(productNames,
                                    FUN = splitProductName,
                                    pattern = replacementPattern,
                                    names = productNamesCleaned)


  areElementsLatent <-
    lapply(elementsInProducts,
           FUN = function(x, indicators)  (x %in% latentVariables),
           indicators)

  numberLatentElements <- lapply(areElementsLatent,
                                 FUN = sum)

  # A product is considered latent if it has at least one latent variable
  isProductLatent <- lapply(numberLatentElements,
                            FUN = as.logical)
  latentProducts <- unlist(productNamesCleaned)[unlist(isProductLatent)]

    # Indicators belonging to latent variables which are specified in the syntax
  indicatorsLatents <- structureLavExpressions(measurementExpressions)

  # If a measurement model for the latent products arent specified we should
  # create our own
  if (isMeasurementSpecified == FALSE) {
    # Get indicators belonging to latent variables, or if observed, just get the
    # observed variable in product terms
    indicatorsInProductTerms <- lapplyNamed(elementsInProducts,
                                          FUN = getIndicatorsMultipleVariables,
                                          indicatorsLatents = indicatorsLatents,
                                          names = productNamesCleaned)
    # Creating a relationalDF for productTerms
    relationalDfs <- lapply(indicatorsInProductTerms,
                            FUN = createRelationalDf,
                            isMeasurementSpecified = FALSE,
                            pattern = NULL)
    # Get a list with all the indicators in each interactionterm
    indicatorsInProductTerms <- lapplyNamed(indicatorsInProductTerms,
                                            FUN = function(x) unname(unlist(x)),
                                            names = productNamesCleaned)
    # create the names for the indicatorProducts
    indicatorNamesProductTerms <- lapplyNamed(relationalDfs,
                                              FUN = colnames,
                                              names = names(relationalDfs))
    indicatorNamesLatents <- c(indicatorsLatents, indicatorNamesProductTerms)

    indicatorProductNamesLatents <-
      indicatorNamesProductTerms[unlist(isProductLatent)]
    inidicatorsInLatentProducts <-
      indicatorsInProductTerms[unlist(isProductLatent)]

  } else if (isMeasurementSpecified == TRUE) {
    # Latents
    latentProductExpressions <-
      measurementExpressions[grepl(replacementPattern, measurementExpressions$lhs), ]

    if (nrow(latentProductExpressions) <= 0) {
      stop2("Error relating to isMeasurementSpecified = TRUE \n",
            "parseLavaan found no mesurement expressions for latent products, ",
            'have you remembered to use ":" when specifying the name of the latent product')
    }

    # fix names in lhs-column
    latentProductExpressions[["lhs"]] <-
      fixProductNames(latentProductExpressions[["lhs"]],
                      pattern = replacementPattern)
    # get the names of latent products to structure the output
    latentProductNames <- fixProductNames(
      unique(latentProductExpressions[["lhs"]]),
      pattern = replacementPattern)
    # Split the expressions based on what product term they belong to
    expressionsLatentProducts <-
      lapplyNamed(latentProductNames,
                  FUN = function(name, df) df[df$lhs == name, ],
                  df = latentProductExpressions)
    # create a list with indicator names in latent product, and fix names
    indicatorProductNamesLatents <-
      lapply(expressionsLatentProducts,
             FUN = function(df) df[["rhs"]])

    # Observed
    elementsInObservedProduct <- elementsInProducts[!(unlist(isProductLatent))]
    indicatorProductNamesObserved <-
      lapply(elementsInObservedProduct,
             FUN = stringr::str_c,
             collapse = replacementPattern)

    # Combining productNames for both, and creating relationalDfs
    indicatorProductNames <- c(indicatorProductNamesLatents,
                               indicatorProductNamesObserved)

    # Get all indicators in the productTerms
    indicatorsInProductTerms <-
      lapply(indicatorProductNames,
             FUN = function(x, pattern) unique(splitProductNamesVec(x, pattern)),
             pattern = replacementPattern)

    # Create relational Dfs
      # This has to be done differently from when measurement is not specified,
        # since we no longer want all productIndicators combinations
    relationalDfs <- lapplyNamed(
      indicatorProductNames,
      FUN = createRelationalDf,
      isMeasurementSpecified = TRUE,
      pattern = replacementPattern,
      names = names(indicatorProductNames))

    indicatorProductNamesLatents <-
      lapplyNamed(indicatorProductNamesLatents,
                  FUN = fixProductNames,
                  pattern = replacementPattern,
                  names = names(indicatorProductNamesLatents))
  }

  # Info nlsem -----------------------------------------------------------------
  etaNames <- unique(structuralExpressions$lhs)
  allPredictors <- unique(structuralExpressions$rhs)
  simplePredictors <- allPredictors[!grepl(replacementPattern, allPredictors)]
  # I do this in the counter intuitive way, to keep the same order as the
  # measurement expressions in the model, which is the way the nlsem model reads
  # the syntax
  latentSimplePredictors <-
    latentVariables[latentVariables %in% simplePredictors]

  nlsemInfo <- list(etaNames = etaNames,
                    indicatorsEta = indicatorsLatents[etaNames],
                   xiNames = latentSimplePredictors,
                   indicatorsXi = indicatorsLatents[latentSimplePredictors],
                   modelSyntax = originalSyntax)

  # Return modelSpecification --------------------------------------------------
  modelSpecification <- list(
    lavaanSyntax = cleanedModelSyntax,
    nlsem = nlsemInfo,
    parTable = parTable,
    productNames = productNamesCleaned,
    elementsInProductNames = elementsInProducts,
    relationalDfs = relationalDfs,
    indicatorsInProductTerms = indicatorsInProductTerms,
    productNamesLatents = names(indicatorProductNamesLatents), # This is not very pretty... but it makes sure they are sorted the same
    indicatorProductNamesLatents = indicatorProductNamesLatents
    )

  modelSpecification
}



# Function for structuring expressions in a parTable ---------------------------
structureLavExpressions <- function(parTable = NULL) {
  # If empty return NULL
  if (is.null(parTable)) return(NULL)
  # Same if nrow <= 0
  else if (nrow(parTable) <= 0) return(NULL)

  ### Get Dependents
  names <- unique(parTable$lhs)

  # see utils for definition of selectValuesByCol() and lapplyNamed()
  lapplyNamed(names, selectValuesByCol, parTable, "rhs" ,"lhs")
}



getIndicatorsVariable <- function(varName = NULL,  indicatorsLatents = NULL) {

  if (is.null(varName)) {
    return(
      stop2("Error in getIndicatorsVariable(), varName is NULL")
    )
  }

  # Get the names of the latent variables in the model
  latentVariables <- names(indicatorsLatents)

  # Check if our varName is a latent- or an observed variable
  if (!(varName %in% latentVariables)) {
    # If it is not a latent variable, we should just return the observed variable
    return(varName)
  } else if (varName %in% latentVariables) {
    # If it is a latent variable, we should return its indicators
    return(indicatorsLatents[[varName]])
  }

  # Error if it is neither a latent- nor an observerd variable
  stop2(
    "Something went wrong in getIndicatorsVariable(), varName neither observed not latent"
  )
}



# Function for getting indicators for mutliple variables -----------------------

getIndicatorsMultipleVariables <- function(varNames = NULL,
                                           indicatorsLatents = NULL) {
  # varNames = vector with variableNames
  # output should be a list

  # Check that arguements are supplied/not NULL
  if (is.null(varNames)) {
    return(
      stop2("Error in getIndicatorsMultipleVariables(), varNames is NULL")
    )
  }

  # use getIndicatorsVariable for each element in varNames, and return a named list
  lapplyNamed(varNames,
              FUN = getIndicatorsVariable,
              indicatorsLatents = indicatorsLatents)
}



splitProductName <- function(productName, pattern) {
  if (is.null(productName)) {
    stop2("productNames in splitProductName was NULL")
  }
  if (is.null(pattern)) {
    stop2("pattern not supplied in splitProductName")
  }
  stringr::str_split_1(productName, pattern)
}



splitProductNamesVec <- function(productNames, pattern) {
  if (is.null(productNames)) {
    stop2("productNames in splitProductNamesVec was NULL")
  }
  if (is.null(pattern)) {
    stop2("pattern not supplied in splitProductName")
  }
  unlist(stringr::str_split(productNames, pattern))
}



fixProductNames <- function(productName, pattern = NULL) {
  if (is.null(pattern)) {
    stop2("pattern not supplied in fixProductNames")
  }
  stringr::str_remove_all(productName, pattern)
}



fixLatentNamesSyntax <- function(modelSyntax, pattern) {
  stringr::str_replace_all(modelSyntax, pattern, "")
}



createRelationalDf <- function(indicatorsProductTerm,
                               isMeasurementSpecified,
                               pattern = NULL) {

  if (isMeasurementSpecified == FALSE) {
    relationalDf <- t(expand.grid(indicatorsProductTerm))

  } else if (isMeasurementSpecified == TRUE) {
    if (is.null(pattern)) {
      stop2("pattern not supplied in createRelationalDf isMeasurementSpecified = TRUE")
    }
    relationalDf <- stringr::str_split_fixed(indicatorsProductTerm,
                                             pattern,
                                             2) |>
                    t() |> as.data.frame()

  }
  names <- apply(relationalDf, MARGIN = 2, FUN = stringr::str_c, collapse = "")

  structure(as.data.frame(relationalDf),
            names = names)

}




