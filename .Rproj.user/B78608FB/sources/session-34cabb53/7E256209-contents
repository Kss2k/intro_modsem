library(lavaan)
library(tidySEM)
setwd("C:/Users/slupp/OneDrive/Skrivebord/MasterOppgaveMehmet/data")
df <- readRDS("TBPn221.rds")




# Step 1:
# Two respective indicators of the interaction term are multiplied



# create the functions assuming a single latent variable
createPairLists <- function(modelSyntax) {
  indicators <- getProductIndicators(modelSyntax)
  PairLists <- vector("list", length = length(indicators))

  for (i in seq_along(indicators)) {
    PairLists[[i]] <- expand.grid(indicators[[i]][[1]], indicators[[i]][[2]])
  }
  PairLists
}


indicatorProducts <- function(pairList) {
  lapply(pairList, function(df) apply(df, 1, multiply))
}



fetchVariables <- function(varnames, data) {
  data[[varnames]]
}

multiply <- function(x) {
  if (length(x) <= 1) return(x)

  product <- x[[1]]*x[[2]]
  newVector <- c(product, x[-(1:2)])
  multiply(newVector)

}

modsem.rca <- function(modelSyntax, data, specifyCovs = TRUE, firstFixed = TRUE ,...) {
  # This function assumes that there is only one latent product term


  indicators <- allIndicatorNames(modelSyntax)


  index <- 1


  latentVarname <- names(indicators)[[index]]



  pairDf <- createPairLists(modelSyntax)[[index]] |>
    t() |>
    as.data.frame()


  productNames <- apply(pairDf, 2, stringr::str_c, collapse = "")
  names(pairDf) <- productNames


  products <- productIndicators(productNames, pairDf, data)

  dfPredictors <- predictorsDependents(pairDf)

  dependentNames <- names(dfPredictors)

  residuals <- products

  for (i in seq_along(dfPredictors)) {
    residuals[[i]] <- residualsProducts(dependentNames[[i]], indicators[[index]], products)
  }

  newData <- data
  newData[dependentNames] <- residuals

  modifiedSyntax <- generateSyntax.rca(modelSyntax = modelSyntax,
                                       latentName = latentVarname,
                                       productIndicators = dependentNames,
                                       pairDf = pairDf,
                                       specifyCovs = specifyCovs,
                                       firstFixed = firstFixed)

  lavaan::sem(modifiedSyntax, newData, ...)
}





productIndicators <- function(productNames, indicatorPairs, data) {
  listOut <- lapply(indicatorPairs, productTwoIndicators, data)
  names(listOut) <- productNames
  as.data.frame(listOut)
}

productTwoIndicators <- function(indicatorPair, data) {
  var1 <- data[[indicatorPair[[1]]]]
  var2 <- data[[indicatorPair[[2]]]]
  var1*var2
}

predictorsDependents <- function(pairDf) {

  allIndicators <- unique(unname(unlist(pairDf)))
  dependents <- apply(pairDf, 2, stringr::str_c, collapse = "")
  predictors <- lapply(pairDf, otherPredictors, allIndicators) |>
    as.data.frame()

  names(predictors) <- dependents
  predictors
}

otherPredictors <- function(dependents,
                            predictors) {
  predictors[!(predictors %in% dependents)]
}

residualsProducts <- function(dependentName,
                              predictorNames,
                              data) {
  formula <- generateFormula(dependentName, predictorNames)
  lm(formula, data = data)$residuals
}



generateFormula <- function(dependentName,
                            predictorNames,
                            operator = "~",
                            firstFixed = FALSE) {

  predictors <- stringr::str_c(predictorNames, collapse = " + ")

  if (firstFixed == TRUE) {
    predictors <- paste0("1*", predictors)
  }
  paste(dependentName, operator, predictors)
}



generateSyntax.rca <- function(modelSyntax,
                               latentName,
                               productIndicators,
                               pairDf,
                               specifyCovs = TRUE,
                               firstFixed = TRUE) {
  # replace :
  colonRemoved <- stringr::str_replace_all(modelSyntax, ":", "")

  # structural model
  structuralModel <- generateFormula(latentName, productIndicators, operator = "=~", firstFixed)

  # residual covariances
  if (specifyCovs == TRUE) {
    residualCovariances <- paste("# ModSEM: Residual (Co)Variances",
                                 syntaxResidualCovariance(pairDf),
                                 sep = "\n  ")
  } else if (specifyCovs == FALSE) {
    residualCovariances <- ""
  }
  # Adding them all together
  newSyntax <- paste(colonRemoved,
                     "# ModSEM: Structural Model",
                     structuralModel,
                     "\n  ",
                     residualCovariances,
                     sep = "\n  ")
  cat(newSyntax, "\n")
  newSyntax
}

# THIS IS just placholder, there is way to much nesting going on
syntaxResidualCovariance<- function(df) {
  n <- ncol(df)
  relationalMatrix <- matrix(FALSE, nrow = n, ncol = n)
  variables <- colnames(df)

  for (i in 1:n) {
    for (j in 1:i) {
      sharedValuesLogical <- sum(df[[variables[i]]] %in% df[[variables[j]]]) >= 1
      relationalMatrix[i, j] <- sharedValuesLogical
    }
  }
  # is this necessary?
  colnames(relationalMatrix) <- variables
  rownames(relationalMatrix) <- variables


  replaceLogical(relationalMatrix)

}


replaceLogical <- function(relationalMatrix) {
  colNames <- colnames(relationalMatrix)


  out <- matrix("", nrow = nrow(relationalMatrix),
                ncol = ncol(relationalMatrix))

  orthogonal <- residualCovariance(colNames,oblique = FALSE)
  oblique <- residualCovariance(colNames, oblique = TRUE)


  out[relationalMatrix == FALSE] <- orthogonal[relationalMatrix == FALSE]
  out[relationalMatrix == TRUE ] <- oblique[relationalMatrix == TRUE]
  out[lower.tri(out)] |>
    stringr::str_flatten(collapse = "\n  ")
}

residualCovariance <- function(varnames, oblique = TRUE) {
  if (oblique == TRUE) {
    operator <- ""
  } else if (oblique == FALSE) {
    operator <- "0*"
  }

  replacement <- outer(varnames, varnames, function(x,y) paste0(x, " ~~ ", operator, y)) |>
    as.matrix()
  colnames(replacement) <- varnames
  rownames(replacement) <- varnames
  replacement
}


# TEsting

example <- '

  # Structural Model
  Attitude =~ ATTD1 + ATTD2 + ATTD4 + ATTD4
  PBC =~ PBC1 + PBC2 + PBC3 + PBC4
  Behaviour =~ PB1 + PB2 + PB3 + PB4
  SN =~ SN1 + SN2 + SN3 + SN4
  TestY =~ ty1 + ty2
  TestX =~ tx1 + tx2

  # Higher order
  Intention =~ PBC + SN + Attitude

  # Inner model
  Behaviour ~ Intention + PBC + Intention:PBC + TestY :TestX
  Behaviour ~ Intention + PBC + TestY :TestX


'
testModel <- '
  # Structural Model
  X =~ x1 + x2 +x3
  Y =~ y1 + y2 + y3
  Z =~ z1 + z2 + z3

  # Inner model
  Y ~ X + Z + X:Z
'

testModelSmall <- '
  # Structural Model
  X =~ x1 + x2
  Y =~ y1 + y2
  Z =~ z1 + z2

  # Inner model
  Y ~ X + Z + X:Z
'

testModelNoInt <- '
  # Structural Model
  X =~ x1 + x2 +x3
  Y =~ y1 + y2 + y3
  Z =~ z1 + z2 + z3

  # Inner model
  Y ~ X + Z
'

#modsem.rca(testModel, testData)[1:5, 1]

matrix(1, ncol = 9, nrow = 9)[lower.tri(matrix(1, ncol = 9, nrow = 9))] |> sum()


model1 <- lavaan::sem(testModelNoInt, testData)
realModel1 <- lm(realY ~ realX + realZ, testData)


model2 <- modsem.rca(testModelSmall, testData, firstFixed = FALSE)
model3 <- modsem.rca(testModelSmall, testData, firstFixed = FALSE, specifyCovs = FALSE)
realModel2_3 <- lm(realY ~ realX*realZ, as.data.frame(scale(testData)))


summary(model2)
summary(model3)
summary(realModel2_3)

# Manual comparison
manualData <- testData
manualData$x1z1 <- manualData$x1*manualData$z1
manualData$x1z2 <- manualData$x1*manualData$z2
manualData$x2z1 <- manualData$x2*manualData$z1
manualData$x2z2 <- manualData$x2*manualData$z2


manualData$res_x1z1 <- lm(x1z1 ~ x1+ z1+ x2 + z2, data = manualData)$residuals
manualData$res_x1z2 <- lm(x1z2 ~ x2 + z1, data = manualData)$residuals
manualData$res_x2z1 <- lm(x2z1 ~ x1 + z2, data = manualData)$residuals
manualData$res_x2z2 <- lm(x2z2 ~ x1 + z1, data = manualData)$residuals


manualSyntax <- '
# Structural Model
  X =~ x1 + x2
  Y =~ y1 + y2
  Z =~ z1 + z2

  # Inner model
  Y ~ X + Z + XZ

  # ModSEM: Structural Model
  XZ =~ res_x1z1 + res_x2z1 + res_x1z2 + res_x2z2


  # ModSEM: Residual (Co)Variances
  res_x2z1 ~~ res_x1z1
  res_x1z2 ~~ res_x1z1
  res_x2z2 ~~ 0*res_x1z1
  res_x1z2 ~~ 0*res_x2z1
  res_x2z2 ~~ res_x2z1
  res_x2z2 ~~ res_x1z2
'

manualModel <- lavaan::sem(manualSyntax, manualData)

library(lavaan)
library(tidySEM)

tidySEM::graph_sem(manualModel)
tidy













